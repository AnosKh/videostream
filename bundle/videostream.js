/**
 * This file is automatically generated. Do not edit it.
 * $Id: videostream.js,v 2.6.1 2018/06/20 12:04:07 dc Exp $
 */
(function(){function r(e,n,t){function o(i,f){if(!n[i]){if(!e[i]){var c="function"==typeof require&&require;if(!f&&c)return c(i,!0);if(u)return u(i,!0);var a=new Error("Cannot find module '"+i+"'");throw a.code="MODULE_NOT_FOUND",a}var p=n[i]={exports:{}};e[i][0].call(p.exports,function(r){var n=e[i][1][r];return o(n||r)},p,p.exports,r,e,n,t)}return n[i].exports}for(var u="function"==typeof require&&require,i=0;i<t.length;i++)o(t[i]);return o}return r})()({1:[function(require,module,exports){
var inherits = require("/bundle/utils").inherit, toArrayBuffer = require("to-arraybuffer"), EventEmitter = require("eventemitter3").EventEmitter, Buffer = require("buffer").Buffer;

module.exports = AudioStream;

var log = console.warn.bind(console, "audiostream");

function AudioStream(t, e, i) {
  var a = this;
  if (!(this instanceof AudioStream)) return new AudioStream(t, e, i);
  EventEmitter.call(a);
  var r = new AudioContext();
  a._buffer = null;
  a._playOffset = 0;
  a._pauseOffset = 0;
  a._hasAudio = !0;
  a._elem = e;
  a._visualiser = null;
  a._audioSource = null;
  a._audioBuffer = null;
  a._videoStream = null;
  a._audioStream = null;
  a._outputStream = null;
  a._videoContext = null;
  a._audioContext = r;
  a._audioAnalyser = null;
  var s = t.createReadStream({
    start: 0
  });
  (a._fileStream = s).on("data", function(t) {
    var e = a._buffer;
    a._buffer = e ? Buffer.concat([ e, t ]) : t;
  });
  s.on("end", function() {
    var t = toArrayBuffer(a._buffer);
    s.destroy();
    r.decodeAudioData(t.slice(0), function(t) {
      try {
        a._setup(t, i.autoplay);
      } catch (t) {
        log(t);
        a.destroy(t);
      }
    });
    a.emit("audio-buffer", t);
  });
  a._onError = function(t) {
    a.destroy(t);
  };
  a._onPause = function() {
    if (a._audioStream) {
      var t = r.currentTime - a._playOffset;
      a._stop();
      a._pauseOffset = t;
    }
  };
  a._onPlay = function() {
    a._audioStream && a._pauseOffset && a._play(a._pauseOffset >= (a._audioBuffer || !1).duration ? 0 : a._pauseOffset);
  };
  e.addEventListener("play", a._onPlay);
  e.addEventListener("pause", a._onPause);
  e.addEventListener("error", a._onError);
}

inherits(AudioStream, EventEmitter);

AudioStream.prototype.destroy = function(t) {
  var e = this;
  if (!e.destroyed) {
    var i = e._elem;
    e.destroyed = !0;
    e._buffer = null;
    e._fileStream.destroy();
    i.removeEventListener("play", e._onPlay);
    i.removeEventListener("pause", e._onPause);
    i.removeEventListener("error", e._onError);
    i.removeAttribute("src");
    i.srcObject = null;
    e._stop();
    var a = e._audioStream;
    a && a.disconnect();
    var r = e._visualiser;
    r && r.destroy();
    var s = e._audioContext;
    s && s.close();
    e.emit("close");
    t && e.emit("error", t);
  }
};

AudioStream.prototype._setup = function(t, e) {
  var i = this, a = i._elem, r = i._audioContext, s = r.createMediaStreamDestination(), o = document.createElement("canvas"), n = o.captureStream(30), u = [ s.stream.getTracks()[0], n.getTracks()[0] ], h = r.createAnalyser();
  s.connect(r.destination);
  i._visualiser = new Visualiser(i);
  i._audioAnalyser = h;
  i._videoContext = o;
  i._videoStream = n;
  i._audioStream = s;
  i._audioBuffer = t;
  i._play(0);
  if (!e) {
    i._onPause();
    i._pauseOffset += .001;
  }
  a.srcObject = new MediaStream(u);
  Object.defineProperty(a, "duration", {
    writable: !0,
    enumerable: !0,
    configurable: !0,
    value: t.duration
  });
};

AudioStream.prototype._stop = function() {
  var t = this, e = t._audioSource, i = t._visualiser;
  if (e) {
    e.disconnect();
    e.stop(0);
  }
  i && i._stop();
  t._playOffset = 0;
  t._pauseOffset = 0;
};

AudioStream.prototype._play = function(t) {
  var e = this, i = e._visualiser, a = e._audioBuffer, r = e._audioContext.createBufferSource();
  r.buffer = a;
  r.connect(e._audioAnalyser);
  r.connect(e._audioStream);
  r.start(0, t);
  r.playbackRate.setValueAtTime(1, t);
  e._audioSource = r;
  e._playOffset = e._audioContext.currentTime - t;
  e._pauseOffset = 0;
  i && i._start();
};

Object.defineProperty(AudioStream.prototype, "currentTime", {
  get: function() {
    var t = this;
    if (t._pauseOffset) return t._pauseOffset;
    var e = 0;
    t._playOffset && (e = t._audioContext.currentTime - t._playOffset);
    e >= (t._audioBuffer || !1).duration && t._elem.pause();
    return e;
  }
});

function AudioVisualiser(t, e) {
  var i = this;
  i._tick = 0;
  i._image = null;
  i._stream = t;
  i._fftSize = e || 16384;
  var a = null;
  i._onResize = function() {
    clearTimeout(a);
    a = setTimeout(function() {
      i._draw();
    }, 50);
  };
  window.addEventListener("resize", i._onResize);
}

inherits(AudioVisualiser, null);

AudioVisualiser.prototype.destroy = function() {
  var t = this;
  if (!t.destroyed) {
    t.destroyed = !0;
    t._tick = null;
    window.removeEventListener("resize", t._onResize);
  }
};

AudioVisualiser.prototype._start = function() {
  this._draw();
};

AudioVisualiser.prototype._stop = function() {
  this._tick = -1;
};

AudioVisualiser.prototype._draw = function() {
  var e = this, i = ++e._tick, t = e._stream, a = t._videoContext, r = t._audioAnalyser, s = $(t._elem).parent();
  a.width = s.outerWidth() + 16 & -16;
  a.height = s.outerHeight() + 16 & -16;
  var o = a.getContext("2d");
  e.init(o, a.width, a.height, a);
  r.fftSize = e._fftSize;
  !function _draw() {
    if (i === e._tick) {
      requestAnimationFrame(_draw);
      var t = new Uint8Array(r.frequencyBinCount);
      r.getByteFrequencyData(t);
      e.draw(t, o, a.width, a.height, a);
    }
  }();
};

function Visualiser(t, e) {
  AudioVisualiser.call(this, t, e);
  this.stars = [];
  this.volume = 0;
  this.gradient = null;
}

inherits(Visualiser, AudioVisualiser);

Visualiser.prototype.init = function(t, e, i, a) {
  var r = t.createLinearGradient(0, 0, 0, 300);
  r.addColorStop(1, "rgba(96, 96, 98, 0.6)");
  r.addColorStop(.75, "rgba(26, 24, 24, 0.8)");
  this.gradient = r;
  var s, o, n, u = e / 24, h = [];
  while (u-- > 0) {
    s = (Math.random() - .5) * e;
    o = (Math.random() - .5) * i;
    n = 3 * (Math.random() + .1);
    h.push(new Star(s, o, n, t, e, i, this));
  }
  this.stars = h;
};

Visualiser.prototype.draw = function(t, e, i, a, r) {
  var s, o, n, u, h, d = 0, l = t.byteLength;
  for (n = 0; n < 80; n++) d += t[n];
  s = (this.volume = d) / 1e3;
  h = u = n = 31 + (Math.sin(s) + 1);
  e.clearRect(0, 0, i, a);
  e.beginPath();
  e.rect(0, 0, i, a);
  (o = e.createRadialGradient(i / 2, a / 2, s / 1.4, i / 2, a / 2, i - Math.min(Math.pow(s / 1.4, 2.7), i - 20))).addColorStop(0, "rgba(0,0,0,0)");
  o.addColorStop(.8, "rgba(" + Math.round(n) + ", " + Math.round(u) + ", " + Math.round(h) + ", 0.4)");
  e.fillStyle = o;
  e.fill();
  e.closePath();
  e.beginPath();
  e.fillStyle = this.gradient;
  while (l--) e.fillRect(5 * l, (a - (s = t[l] / 1.4)) / 1.2, 4, s / 1.3);
  e.closePath();
  var f = this._stream._audioAnalyser;
  t = new Uint8Array(f.frequencyBinCount);
  f.getByteTimeDomainData(t);
  e.beginPath();
  e.lineWidth = 1;
  e.strokeStyle = "rgba(217, 0, 7, 0.8)";
  e.moveTo(0, a - t[0]);
  l = t.byteLength;
  while (l--) e.lineTo(l, a - t[l]);
  e.stroke();
  e.closePath();
  e.beginPath();
  e.translate(i / 2, a / 2);
  for (n = this.stars.length; n--; ) this.stars[n].drawStar();
  e.setTransform(1, 0, 0, 1, 0, 0);
};

function Star(t, e, i, a, r, s, o) {
  this.x = t;
  this.y = e;
  this.width = r;
  this.height = s;
  this.angle = Math.atan(Math.abs(e) / Math.abs(t));
  this.starSize = i;
  this.ctx = a;
  this.high = 0;
  this.parent = o;
}

Star.prototype.drawStar = function() {
  var t = Math.sqrt(Math.pow(this.x, 2) + Math.pow(this.y, 2)), e = 200 + Math.min(Math.round(5 * this.high), 55);
  this.ctx.lineWidth = .5 + t / 2e3 * Math.max(this.starSize / 2, 1);
  this.ctx.strokeStyle = "rgba(" + e + ", " + e + ", " + e + ", 0.8)";
  this.ctx.beginPath();
  this.ctx.moveTo(this.x, this.y);
  var i = 1 + Math.min(Math.pow(t, 2) / 3e4 * Math.pow(this.parent.volume, 2) / 6e6, t / 16), a = Math.cos(this.angle) * -i, r = Math.sin(this.angle) * -i;
  this.ctx.lineTo(this.x + (a *= this.x > 0 ? 1 : -1), this.y + (r *= this.y > 0 ? 1 : -1));
  this.ctx.stroke();
  this.ctx.closePath();
  var s = i / 20 * this.starSize;
  this.high -= Math.max(this.high - 1e-4, 0);
  s > this.high && (this.high = s);
  var o = Math.cos(this.angle) * this.high, n = Math.sin(this.angle) * this.high;
  this.x += this.x > 0 ? o : -o;
  this.y += this.y > 0 ? n : -n;
  var u = this.height / 2 + 500, h = this.width / 2 + 500;
  if (this.y > u || this.y < -u || this.x > h || this.x < -h) {
    this.x = (Math.random() - .5) * this.width / 3;
    this.y = (Math.random() - .5) * this.height / 3;
    this.angle = Math.atan(Math.abs(this.y) / Math.abs(this.x));
  }
};
},{"/bundle/utils":3,"buffer":8,"eventemitter3":13,"to-arraybuffer":36}],2:[function(require,module,exports){
"use strict";

var MAX_CACHE = 0 | localStorage.maxStreamingCache || 524288e3, MIN_CACHE = 0 | localStorage.minStreamingCache || 419430400, REQUEST_SIZE = 4194304, MAX_BUF_SECONDS = 25, VideoStream = require("../videostream"), AudioStream = require("../audiostream"), inherits = require("/bundle/utils").inherit, Readable = require("readable-stream").Readable, Buffer = require("buffer").Buffer;

function CacheStream(e, t) {
  if (!(this instanceof CacheStream)) return new CacheStream(e, t);
  Readable.call(this);
  this.pos = e;
  this._file = t;
  this._file.stream = this;
  var i = t.minCache, r = t.cachefind(e);
  r < 0 && (r = -r - 1);
  t.mru++;
  while (r < t.cachepos.length && i > 0) {
    e = t.cachepos[r++];
    i -= t.cache[e].byteLength;
    t.cachemru[e] = t.mru;
  }
}

inherits(CacheStream, Readable);

CacheStream.prototype._read = function(e) {
  e = window.chrome ? 1048576 : 262144;
  if (this._file && this._file._vs) {
    var t = this._file, i = t._vs, r = t.filesize, s = i._elem.currentTime, a = s && !t.seeking && i.bufTime;
    if (a > MAX_BUF_SECONDS) {
      t.throttle = s + a;
      d && console.debug("[CacheStream._read()] Max buffered seconds reached, throttling until %s (current playback time is %s)...", secondsToTime(t.throttle), secondsToTime(s));
    } else {
      while (e) {
        var o = t.cachefind(this.pos);
        if (o < 0) {
          t.fetch(this.pos);
          break;
        }
        var n = this.pos - (o = t.cachepos[o]), h = e;
        t.cache[o].byteLength - n < h && (h = t.cache[o].byteLength - n);
        if (h <= 0) break;
        e -= h;
        this.pos += h;
        t.cachemru[this.pos] = t.mru++;
        if (!this.push(Buffer.from(t.cache[o], n, h))) break;
      }
      r && this.pos === r && this.push(null);
    }
  }
};

CacheStream.prototype._destroy = function(e, t) {
  this._file.stream = !1;
  t(e);
};

function VideoFile(e, t) {
  this.data = e;
  this.stream = null;
  this.streamer = t;
  this.cache = Object.create(null);
  this.cachemru = Object.create(null);
  this.fetching = Object.create(null);
  this.cachepos = [];
  this.cachesize = 0;
  this.mru = 0;
  this.curfetch = 0;
  this.filesize = -1;
  this.throttle = 0;
  this.backoff = 200;
  this.paused = !0;
  this.playing = !1;
  this.canplay = !1;
  this.bgtask = !t.options.autoplay;
  this.retryq = [];
  this.minCache = MIN_CACHE;
  this.maxCache = MAX_CACHE;
  if (e instanceof Blob) {
    this.minCache = 10485760;
    this.maxCache = 41943040;
    this.fetcher = this.fileReader;
  }
  window.addEventListener("online", this);
}

VideoFile.prototype = Object.create(null);

Object.defineProperty(VideoFile.prototype, "isOnline", {
  get: function() {
    return !1 !== navigator.onLine;
  }
});

VideoFile.prototype.handleEvent = function(e) {
  d && console.debug("[VideoFile.handleEvent()]", e.type, e);
  "online" !== e.type || this.overquota || this.flushRetryQueue();
};

VideoFile.prototype.destroy = function() {
  for (var e = Object.keys(this), t = e.length; t--; ) delete this[e[t]];
  window.removeEventListener("online", this);
  Object.freeze(this);
};

VideoFile.prototype.flushRetryQueue = function() {
  if (this.retryq && this.retryq.length) {
    for (var e = 0; e < this.retryq.length; e++) later(this.retryq[e]);
    this.retryq = [];
  }
};

VideoFile.prototype.createReadStream = function(e) {
  return new CacheStream(e.start || 0, this);
};

VideoFile.prototype.cachefind = function(e) {
  var t = this.cachepos.length;
  if (!t) return -1;
  if (e < this.cachepos[0]) return -1;
  for (var i = 0; ;) {
    var r = i + t >> 1;
    if (e >= this.cachepos[r]) {
      if (e < this.cachepos[r] + this.cache[this.cachepos[r]].byteLength) return r;
      i = r + 1;
    } else t = r;
    if (i == t) return -t - 1;
  }
};

VideoFile.prototype.cacheadd = function(e, t) {
  var i = this.cachefind(e);
  if (i >= 0) console.error("*** Mediacache: Internal error - clash"); else if ((i = -i - 1) < this.cachepos.length && e + t.byteLength > this.cachepos[i]) console.error("*** Mediacache: Internal error - overlap"); else {
    this.cachepos.splice(i, 0, e);
    this.cache[e] = t;
    this.cachemru[e] = this.mru++;
    this.cachesize += t.byteLength;
    if (this.cachesize > this.maxCache) {
      var r = this, s = this.cachepos.slice(0);
      s.sort(function(e, t) {
        return (r.cachemru[e] > r.cachemru[t]) - (r.cachemru[e] < r.cachemru[t]);
      });
      for (var a = 0; this.cachesize > this.minCache; a++) {
        var o = s[a];
        this.cachesize -= this.cache[o].byteLength;
        delete this.cache[o];
        delete this.cachemru[o];
        this.cachepos.splice(this.cachepos.indexOf(o), 1);
      }
    }
  }
};

VideoFile.prototype.fetcher = function(e, t, i) {
  return M.gfsfetch(e, t, i);
};

VideoFile.prototype.fileReader = function(s, a, o) {
  return a > s.size ? Promise.reject(ERANGE) : new Promise(function(e, t) {
    var i = s.slice(a, o), r = new FileReader();
    r.onload = function() {
      e({
        buffer: r.result,
        s: s.size
      });
    };
    r.onerror = t;
    r.readAsArrayBuffer(i);
  });
};

VideoFile.prototype.fetch = function(s, a) {
  var e, o = this, n = s;
  if (a && this.paused && this.cachesize >= this.minCache && this.canplay) d && console.debug("[VideoFile.fetch()] MIN_CACHE reached, will not fetch more data until no longer %s...", this.paused ? "paused" : "throttled"); else if (void 0 !== this.mru) {
    this.curfetch += !a;
    var t;
    do {
      t = REQUEST_SIZE;
      while ((e = this.cachefind(n)) >= 0) {
        n = this.cachepos[e] + this.cache[this.cachepos[e]].byteLength;
        t = 0;
      }
      while (this.fetching[n]) {
        n += this.fetching[n];
        t = 0;
      }
    } while (!t);
    if ((e = -e - 1) < this.cachepos.length) {
      var i = this.cachepos[e] - n;
      i < t && (t = i);
    }
    for (e in this.fetching) {
      if (n >= (e *= 1) && n < e + this.fetching[e]) return;
      e >= n && e - n < t && (t = e - n);
    }
    this.filesize >= 0 && n + t >= this.filesize && (t = this.filesize - n);
    if (!(t < 1)) {
      this.fetching[n] = t;
      var r = this.curfetch;
      d && console.debug("Fetching %s-%s, length=%s...", n, n + t, t);
      this.fetcher(this.data, n, n + t).then(function(e) {
        var t = e.buffer;
        delete e.buffer;
        if (void 0 !== o.mru) {
          if ("string" === typeof o.data) {
            e._ticket = o.data;
            o.data = e;
          }
          o.filesize < 0 && (o.filesize = e.s);
          delete o.fetching[n];
          o.cacheadd(n, t);
          n += t.byteLength;
          r === o.curfetch && setTimeout(o.fetch.bind(o, n, 1), 100);
          o.feedPlayer();
          o.backoff = 200;
          o.overquota = !1;
        }
      }).catch(function(e, t) {
        var i = e && e.target || !1;
        if (void 0 !== o.mru) {
          delete o.fetching[n];
          var r = function() {
            window.setImmediate(o.fetch.bind(o, s, a));
          };
          if ("number" === typeof e) {
            if (e !== ERANGE || t && n < t.s) {
              d && console.warn("Unrecoverable stream fetch error, aborting...", o.isOnline, e, n);
              o.streamer.notify("error", new Error(api_strerror(e)));
            }
          } else if (509 === i.status) {
            d && console.warn("stream overquota, holding...", e);
            "object" === typeof o.data && (o.data = o.data._ticket);
            o.overquota = !0;
            o.retryq.push(r);
          } else {
            d && console.warn("stream fetch error, retrying...", o.isOnline, e);
            if (o.isOnline) if (i.status) {
              o.backoff = Math.min(o.backoff << 1, 7e3);
              setTimeout(r, o.backoff);
            } else r(); else o.retryq.push(r);
          }
        }
      });
      return this;
    }
    t < 0 && console.error("*** Mediacache: Internal error - out of bound.", s, n, t);
  }
};

VideoFile.prototype.feedPlayer = function() {
  if (this.stream) try {
    this.stream._read(0);
  } catch (e) {
    this.streamer.notify("error", e);
  }
};

/**
 * Start streaming a MEGA file.
 * @param {String} data The data needed by gfsfetch()
 * @param {Object} video The <video> element
 * @param {Object} [options] Additional options
 * @constructor
 * @preserve
 */ function Streamer(e, t, i) {
  var r = ua.details;
  if (!(this instanceof Streamer)) return new Streamer(e, t, i);
  this.gecko = "Gecko" === r.engine;
  this.options = Object.assign(Object.create(null), {
    autoplay: !0
  }, i);
  this._events = [ "progress", "timeupdate", "canplay", "pause", "playing", "error", "abort", "updateend", "ended", "stalled", "suspend" ];
  if (t.parentNode && this.gecko && parseInt(r.version) < 57) {
    this.sbflush = !0;
    this._events.push("seeking");
    this.WILL_AUTOPLAY_ONSEEK = !0;
  }
  for (var s = this._events.length; s--; ) t.addEventListener(this._events[s], this, !1);
  this.video = t;
  this.timeupdate = 0;
  this.stalled = !1;
  this.inactivity = !1;
  this.activitimer = null;
  this.evs = Object.create(null);
  void (this.presentationOffset = 0) === this.options.type ? this.initTypeGuess(e) : this.init(e);
  d && (window.strm = this);
}

Streamer.prototype = Object.create(null);

Streamer.prototype.init = function(e) {
  var i = this;
  if (i.video) {
    i.file = new VideoFile(e, i);
    !1 === i.options.autoplay ? i.file.minCache = 16777216 : i.video.setAttribute("autoplay", !0);
    var t = Object.assign(i.options, {
      sbflush: i.sbflush,
      bufferDuration: 1.8 * MAX_BUF_SECONDS
    });
    if (this.goAudioStream) {
      i.stream = new AudioStream(i.file.fetch(0), i.video, t);
      [ "error", "audio-buffer" ].forEach(function(t) {
        i.stream.on(t, function(e) {
          i.notify(t, e);
        });
      });
    } else {
      i.stream = new VideoStream(i.file.fetch(0), i.video, t);
      if (i.gecko) {
        var r = !1;
        !function _() {
          if (!r) {
            r = !0;
            i.on("stalled", function() {
              var e = this.stream.getBufferedRange();
              d && console.log("First range on stalled", e, this.timeupdate);
              if (!this.timeupdate && e[0] > 1) {
                console.warn("Applying presentation timestamp fixup...", e);
                this.presentationOffset = e[0];
                this.currentTime = 0;
              }
              return r = !e;
            });
            i.on("ended", _);
          }
        }();
      }
    }
    i.file._vs = i.stream;
  } else d && console.debug("Cannot initialize... already destroyed?", i);
};

Streamer.prototype.initTypeGuess = function(r) {
  var s = this, t = new VideoFile(r, s), a = function(e) {
    t.destroy();
    s.init(e);
  };
  t.fetcher(r, 0, 16).then(function(e) {
    var t = new DataView(e.buffer), i = t.getUint32(0, !1);
    delete e.buffer;
    440786851 === i ? s.options.type = "WebM" : i >> 8 === 4801587 ? s.options.type = "MPEG Audio" : 1332176723 === i ? s.options.type = "Ogg" : 1295270176 === t.getUint32(8, !1) ? s.options.type = "M4A " : 1463899717 === t.getUint32(8, !1) && (s.options.type = "Wave");
    a("string" === typeof r ? e : r);
  }).catch(function(e) {
    d && console.debug("Type guess failed...", e);
    a(r);
  });
};

Streamer.prototype.destroy = function() {
  var e;
  d && console.debug("Destroying Streamer instance.", this);
  this._clearActivityTimer();
  try {
    this.stream.destroy();
  } catch (e) {
    console.warn(e);
  }
  this.file && this.file.destroy();
  if (this.video) {
    for (e = this._events.length; e--; ) this.video.removeEventListener(this._events[e], this);
    if (this.video.parentNode) {
      var t = this.video, i = t.cloneNode(), r = t.parentNode;
      i.removeAttribute("src");
      i.removeAttribute("autoplay");
      r.removeChild(t);
      r.appendChild(i);
    }
  }
  delete this.file;
  delete this.video;
};

Streamer.prototype.onPlayBackEvent = function(e) {
  var t = this.file;
  if (t.paused) {
    t.paused = !1;
    if (t.stream) {
      d && console.debug("Was paused, continuing fetching data...");
      t.fetch(t.stream.pos);
    }
  }
  if (e) {
    t.playing = !0;
    t.seeking = !1;
    this._setActivityTimer();
    if (this.stalled) {
      this.stalled = !1;
      this.notify("activity");
      "ActiveXObject" in window && (this.video.currentTime = this.video.currentTime - .2);
    }
    this.inactivity = !1;
  }
};

Streamer.prototype.handleEvent = function(e) {
  var t = e.target, i = this.file;
  (d && "timeupdate" !== e.type || d > 2) && console.debug("Event(%s)", e.type, t, e);
  switch (e.type) {
   case "seeking":
    i.seeking = !0;
    this.stream.flushSourceBuffers();
    this.video.paused && onIdle(this.play.bind(this));

   case "playing":
    this.onPlayBackEvent("playing" === e.type);
    break;

   case "pause":
    i.paused = !0;
    i.playing = !1;
    this._clearActivityTimer();
    break;

   case "progress":
    t.removeEventListener("progress", this);
    if (d > 1) {
      this.stream._elemWrapper._mediaSource.addEventListener("sourceclose", console.warn.bind(console));
      this.stream._elemWrapper._mediaSource.addEventListener("sourceended", console.warn.bind(console));
    }
    if (i.playing) break;

   case "canplay":
    i.canplay = !0;
    this.options.autoplay && !i.playing && this.play();
    break;

   case "ended":
    this._clearActivityTimer();
    this.stream.flushSourceBuffers(-1);
    break;

   case "stalled":
    if (!i.bgtask) {
      this.stalled = !0;
      this._setActivityTimer();
    }
    break;

   case "timeupdate":
    if (i.throttle && i.throttle - t.currentTime < MAX_BUF_SECONDS / 3) {
      d && console.debug("[Streamer.timeupdate] Throttle threshold %s reached at playback time %s, resuming...", secondsToTime(i.throttle), secondsToTime(t.currentTime), !!i.stream);
      i.throttle = 0;
      i.stream && i.stream._read(0);
    }
    if (this.timeupdate !== t.currentTime) {
      this.timeupdate = t.currentTime;
      this.inactivity ? this.onPlayBackEvent(!0) : this._setActivityTimer();
    }
  }
  if (this.evs[e.type]) {
    var r;
    if ("error" === e.type) {
      var s = t.error || !1, a = this.stream._elemWrapper.detailedError;
      r = a || s.message;
      s.code && console.warn("MediaError %s", s.code, s.message);
      a && console.warn("StreamError", a);
    }
    this.notify(e, r || !1);
  }
};

Streamer.prototype.play = function() {
  try {
    var e = this.video, t = e.play();
    "undefined" !== typeof Promise && t instanceof Promise && t.then(function() {
      d && console.debug("Playing, current time: %s, duration: %s", secondsToTime(e.currentTime), secondsToTime(e.duration));
    }).catch(function(e) {
      d && console.debug("video.play() failed...", e);
    });
  } catch (e) {}
  var i = this.file || !1;
  if (i.bgtask) {
    i.bgtask = !1;
    i.minCache = MIN_CACHE;
    if (i.overquota) {
      this.stalled = !0;
      this._setActivityTimer();
    } else i.flushRetryQueue();
    this.options.autoplay = !0;
  }
};

Streamer.prototype.on = function(e, t, i) {
  t = tryCatch(t.bind(this), i);
  this.evs[e] ? this.evs[e].push(t) : this.evs[e] = [ t ];
  return this;
};

Streamer.prototype.notify = function(e) {
  var t = String("object" === typeof e && e.type || e);
  if (this.evs[t]) {
    for (var i = new Array(arguments.length), r = i.length; r--; ) i[r] = arguments[r];
    "object" !== typeof e && (i[0] = {
      type: t,
      target: this
    });
    this.evs[t] = this.evs[t].filter(function(e) {
      return e.apply(null, i);
    });
    this.evs[t].length || delete this.evs[t];
  }
};

Streamer.prototype._clearActivityTimer = function() {
  if (this.activitimer) {
    clearTimeout(this.activitimer);
    this.activitimer = null;
  }
};

Streamer.prototype._setActivityTimer = function() {
  var t = this;
  this._clearActivityTimer();
  this.activitimer = setTimeout(function() {
    if (t.stalled) {
      var e = t.video;
      if (!e.paused && !e.ended || t.file.overquota) {
        t.notify("inactivity");
        t.inactivity = !0;
      }
    }
  }, 1600);
};

Streamer.prototype.getImage = function(c, u) {
  var f = this, l = this.video;
  return new Promise(function _(e, t) {
    if (!l.videoWidth) return t(-9);
    var i = f.dim(l.videoWidth, l.videoHeight, c || 1280, u || 720);
    d && console.debug("[Streamer.getImage()] Taking %sx%s image from %sx%s at %s", i.width, i.height, l.videoWidth, l.videoHeight, secondsToTime(l.currentTime));
    var r = document.createElement("canvas"), s = r.getContext("2d");
    r.width = Math.round(i.width);
    r.height = Math.round(i.height);
    s.drawImage(l, 0, 0, r.width, r.height);
    var a, o = s.getImageData(0, 0, r.width, r.height).data, n = a = o.byteLength, h = 0;
    while (a--) o[a] < 10 && h++;
    if (Math.round(100 * h / n) > 70) {
      d && console.debug("[Streamer.getImage()] Got +70% of black pixels, retrying...");
      l.paused ? t(-5) : l.ended ? t(-8) : setTimeout(_.bind(this, e, t), 800);
    } else e(dataURLToAB(r.toDataURL("image/png")));
  });
};

Streamer.prototype.dim = function(e, t, i, r) {
  var s = Math.min(i / e, r / t);
  return {
    width: e * s,
    height: t * s,
    ratio: s
  };
};

Streamer.getThumbnail = function(n) {
  return new Promise(function(t, i) {
    var e = document.createElement("video");
    e.muted = !0;
    var r = -1, s = Streamer(n, e), a = function(e) {
      s.destroy();
      i(e);
    }, o = function(e) {
      t(e);
      s.destroy();
    };
    s.on("playing", function() {
      if (!++r) {
        this.currentTime = 20 * (0 | e.duration) / 100;
        return !0;
      }
      s.getImage().then(o).catch(a);
    });
    s.on("error", a);
  });
};

Object.defineProperty(Streamer.prototype, "duration", {
  get: function() {
    return (this.video || !1).duration - this.presentationOffset | 0;
  }
});

Object.defineProperty(Streamer.prototype, "currentTime", {
  get: function() {
    var e = this.stream || !1;
    return e instanceof AudioStream ? e.currentTime : (this.video || !1).currentTime - this.presentationOffset;
  },
  set: function(e) {
    var t = this.video || !1, i = this.stream || !1;
    i instanceof AudioStream ? i._play(e) : t.currentTime = e + this.presentationOffset;
  }
});

Object.defineProperty(Streamer.prototype, "goAudioStream", {
  get: function() {
    var e = (this.options || !1).type;
    return "M4A " === e ? mega.fullAudioContextSupport : "MPEG Audio" === e || "Wave" === e || "Ogg" === e;
  }
});

Object.defineProperty(Streamer.prototype, "hasAudio", {
  get: function() {
    return this.stream && (Object(this.stream._muxer)._hasAudio || this.stream._hasAudio);
  }
});

Object.defineProperty(Streamer.prototype, "hasUnsupportedAudio", {
  get: function() {
    return this.stream && Object(this.stream._muxer)._hasUnsupportedAudio;
  }
});

Object.defineProperty(Streamer.prototype, "hasVideo", {
  get: function() {
    return this.stream && Object(this.stream._muxer)._hasVideo;
  }
});

/**
 *  @global
 *  @preserve
 *  @name Streamer
 */ Object.defineProperty(self, "Streamer", {
  value: Object.freeze(Streamer)
});
},{"../audiostream":1,"../videostream":39,"/bundle/utils":3,"buffer":8,"readable-stream":35}],3:[function(require,module,exports){
var Buffer = require("buffer").Buffer, onNextTick = function(e) {
  setTimeout(e, 0);
};

"undefined" !== typeof requestIdleCallback && (onNextTick = function(e) {
  requestIdleCallback(function() {
    e();
  });
});

var utils = {
  debuglog: function(e) {
    if (d > 8) {
      var t = MegaLogger.getLogger(e);
      return t.debug.bind(t);
    }
    return function() {};
  },
  nextTick: function() {
    var e = arguments[0];
    if (arguments.length > 1) {
      arguments[0] = null;
      onNextTick(Function.prototype.bind.apply(e, arguments));
    } else onNextTick(e);
  },
  inherit: function(e, t) {
    e.prototype = Object.create(t && t.prototype || t);
    Object.defineProperty(e.prototype, "constructor", {
      value: e,
      enumerable: !1
    });
  },
  deprecate: function(e, t) {
    var n = !1;
    return function() {
      if (!n) {
        n = !0;
        console.warn(t);
      }
      return e.apply(this, arguments);
    };
  },
  isU8: function(e) {
    return e instanceof Uint8Array || Buffer.isBuffer(e);
  }
};

module.exports = utils;
},{"buffer":8}],4:[function(require,module,exports){
"use strict";

var inherits = require("/bundle/utils").inherit, Buffer = require("buffer").Buffer, stream = require("readable-stream"), EventEmitter = require("eventemitter3").EventEmitter, EBMLDecoder = require("ebml/lib/ebml/decoder");

module.exports = EBMLRemuxer;

if (d > 99) {
  var tmp = function() {
    this.$etup();
  };
  createStream(tmp, EBMLDecoder);
  EBMLDecoder = tmp;
}

function EBMLRemuxer(e) {
  var t = this;
  this.$etup();
  this._file = e;
  this._tracks = [];
  this._seekTime = -1;
  this._hasVideo = !1;
  this._hasAudio = !1;
  this._seekTable = !1;
  this._seekTimeFixup = -1;
  this._initSegment = !1;
  this._createReader(0, "segment", function(e) {
    this.destroy();
    t.setInitSegment(e);
  });
}

createStream(EBMLRemuxer, EventEmitter);

EBMLRemuxer.prototype.emitInitSegment = function(t) {
  var e = t.Tracks;
  d && console.log("initSegment", t, [ this ]);
  if (!e) return this.destroy(new Error("Unsupported media format."));
  for (var i = function(e) {
    return String(e).substr(2).toLowerCase();
  }, s = function(e, t) {
    switch (e) {
     case "A_VORBIS":
     case "A_OPUS":
     case "V_VP8":
     case "V_VP9":
      return (1 === t ? "video" : "audio") + '/webm; codecs="' + i(e) + '"';
    }
  }, r = e.length; r--; ) {
    var n = e[r], a = n.CodecID, o = n.TrackType, h = s(a, o);
    d && console.debug("Track%s, %s, %s", n.TrackNumber, a, h, n);
    if (h) {
      if (this._hasVideo || 1 !== o) {
        if (this._hasAudio || 2 !== o) continue;
        if (!MediaSource.isTypeSupported(h)) {
          d && console.debug("Unsupported audio track.", h);
          continue;
        }
        this._hasAudio = a;
      } else this._hasVideo = a;
      n.mime = h;
    }
  }
  if (this._hasVideo) {
    h = 'video/webm; codecs="' + i(this._hasVideo);
    this._hasAudio && (h += "," + i(this._hasAudio));
    this._tracks.push({
      mime: h + '"'
    });
  } else this._hasAudio && this._tracks.push({
    mime: 'audio/webm; codecs="' + i(this._hasAudio) + '"'
  });
  if (!this._tracks.length) return this.destroy(new Error("no playable tracks"));
  if (t.Cues) {
    this._shrink(t, {
      Cues: "CuePoint"
    });
    for (var u = t.Cues, f = t.playtime, c = this._seekTable = [], l = u.length; l--; ) {
      var m = u[l], _ = m.CueTrackPositions, p = Math.round(m.CueTime * t.timescale * 1e3) / 1e3;
      c.push([ p, f, _.CueClusterPosition + t.offset ]);
      f = p;
    }
  }
  var g = this._tracks.map(function(e) {
    return {
      mime: e.mime,
      init: t.data
    };
  });
  this._initSegment = t;
  this.emit("ready", g);
};

EBMLRemuxer.prototype._shrink = function(e, t) {
  for (var i in t) e[i] && (e[i] = e[i][t[i]]) && (Array.isArray(e[i]) || (e[i] = [ e[i] ]));
};

EBMLRemuxer.prototype._createReader = function(e, t, i, s) {
  var r = new EBMLReader(this._file, e);
  if ("string" === typeof t) {
    s = i;
    i = t;
    t = this;
  }
  r.on(i, function() {
    s.apply(r, arguments);
  });
  r.on("error", function(e) {
    t.destroy(e);
  });
  return r;
};

EBMLRemuxer.prototype.setInitSegment = function(t) {
  var i = this, e = t.Info;
  if (e) {
    t.timescale = e.TimecodeScale / 1e9;
    t.playtime = e.Duration * t.timescale;
  }
  this._shrink(t, {
    Tracks: "TrackEntry",
    SeekHead: "Seek",
    Tags: "Tag"
  });
  if (!t.Cues && t.SeekHead) {
    for (var s = -1, r = t.SeekHead.length; r--; ) {
      var n = t.SeekHead[r];
      if (475249515 === n.SeekID.readInt32BE()) {
        s = n.SeekPosition + t.offset;
        break;
      }
    }
    if (s > 0) {
      this._createReader(s, "cues", function(e) {
        t.Cues = e.Cues;
        i.emitInitSegment(t);
        this.destroy();
      });
      return;
    }
  }
  this.emitInitSegment(t);
};

EBMLRemuxer.prototype._findCluster = function(e) {
  var t = 0, i = this._seekTable;
  this._seekTime = e = Math.round(1e3 * e) / 1e3;
  for (var s = 0; s < i.length; ++s) {
    var r = i[s][0];
    if (e >= r && e <= i[s][1]) {
      e = r;
      t = i[s + 1] ? i[s + 1][2] : i[s][2];
      break;
    }
  }
  this._seekTimeFixup = e;
  return t || this._initSegment.data.length;
};

EBMLRemuxer.prototype.seek = function(e) {
  var i = this, s = i._findCluster(e);
  return i._tracks.map(function(e, t) {
    e.outStream && e.outStream.destroy();
    return e.outStream = new MediaSegment(i, s);
  });
};

function EBMLReader(e, t) {
  this.$etup();
  this._file = e;
  this._conGroup = 0;
  this._cluster = null;
  this._ebmlOffset = 0;
  this._clusterCount = 0;
  this._segmentOffset = 0;
  this._timecodes = [ 0, 0 ];
  this._byteOffset = t;
  this._trackDefaultDuration = 0;
  this._segment = Object.create(null);
  this.$buffer = new Buffer(33554432);
  this.$head = 0;
  this._decoder = new EBMLDecoder();
  this._fileStream = e.createReadStream({
    start: t
  });
  this._fileStream.pipe(this);
  var i = this;
  this._decoder.on("data", function(e) {
    i._onData(e[0], e[1]);
  });
  this.on("finish", function() {
    i._onFinish();
  });
}

createStream(EBMLReader, stream.Writable, function() {
  if (this._fileStream) {
    this._fileStream.destroy();
    this._fileStream = null;
  }
  if (this._decoder) {
    this._decoder.end();
    this._decoder.destroy();
    this._decoder = null;
  }
  this.$buffer = null;
  this._cluster = null;
  while (this._conGroup-- > 0) console.groupEnd();
});

EBMLReader.prototype._getValue = function(e) {
  var t = e.data;
  if ("b" === e.type) return t;
  if ("s" === e.type) return t.toString("ascii");
  if ("8" === e.type) return t.toString("utf-8");
  if ("f" === e.type) return e.dataSize < 8 ? t.readFloatBE() : t.readDoubleBE();
  for (var i = 0, s = 0; s < e.dataSize; s++) i |= t[s] << 8 * (e.dataSize - s - 1);
  return i;
};

EBMLReader.prototype._emitCluster = function(e) {
  this.emit("cluster", this._cluster, this._timecodes[1 & ~this._clusterCount], e);
  this._cluster = null;
};

EBMLReader.prototype._onFinish = function() {
  null !== this._cluster && this._emitCluster(-1);
  this.emit("cluster", null);
  this.destroy();
};

EBMLReader.prototype._onData = function(e, t) {
  var i;
  if (d > 2 && "SimpleBlock" !== t.name) {
    if ("start" === e) {
      this._conGroup++;
      console.group(t.name);
    }
    console.log("state=%s, data=%s", e, t.name, "tag" === e && [ this._getValue(t) ], t);
    if ("end" === e) {
      this._conGroup--;
      console.groupEnd();
    }
  }
  if ("start" === e) {
    if (!this._byteOffset) if ("EBML" === t.name) this._ebmlOffset = t.start; else if ("Segment" === t.name) this._segmentOffset = -1; else if (this._segmentOffset < 0) this._segmentOffset = t.start; else if ("Cluster" === t.name) {
      var s = this._segment;
      this._segment = !1;
      delete s.$;
      s.offset = this._segmentOffset;
      s.data = this._read(this._ebmlOffset, t.start);
      var r = this._trackDefaultDuration;
      if (r) {
        d && console.debug("Cleaning DefaultDuration...\n" + hexdump(s.data, r.start).slice(0, 4).join("\n"));
        var n = r.dataSize;
        if (n > 4) console.warn("Unexpected default duration...", r); else {
          s.data.writeUInt32BE(629573760 + n, r.start);
          while (n-- > 0) s.data.writeUInt8(32, 4 + r.start + n);
        }
      }
      this.emit("segment", s);
      return;
    }
    if ("Cues" === t.name && null !== this._cluster) return this._onFinish();
    (i = Object.create(null)).$ = this._segment;
    this._segment[t.name] ? Array.isArray(this._segment[t.name]) ? this._segment[t.name].push(i) : this._segment[t.name] = [ this._segment[t.name], i ] : this._segment[t.name] = i;
    this._segment = i;
  } else if ("end" === e) {
    this._segment = (i = this._segment).$;
    delete i.$;
    if (t.end - t.start > 0) {
      var a = t.name.toLowerCase();
      if (this.listenerCount(a)) {
        var o = this._read(t.start, t.end);
        if ("cluster" === a) this._cluster = o; else {
          if ("cues" === a) {
            (i = this._segment).data = o;
            o = i;
          }
          this.emit(a, o);
        }
      }
    } else console.warn("Empty master element...", t);
  } else {
    this._segment[t.name] = this._getValue(t);
    if ("Timecode" === t.name) {
      var h = 1 & ++this._clusterCount;
      this._timecodes[h] = this._getValue(t);
      null !== this._cluster && this._emitCluster(this._timecodes[h] - this._timecodes[1 & ~h]);
    } else "DefaultDuration" === t.name && (this._trackDefaultDuration = t);
  }
};

EBMLReader.prototype._read = function(e, t) {
  var i = t - e, s = new Buffer(i), r = e % this.$buffer.length, n = this.$buffer.length - r;
  if (i > this.$buffer.length) this.destroy(new Error("ebml:read buffer overflow.")); else if (i > n) {
    this.$buffer.copy(s, 0, r, this.$buffer.length);
    this.$buffer.copy(s, n, 0, i - n);
  } else this.$buffer.copy(s, 0, r, r + i);
  return s;
};

EBMLReader.prototype._write = function(e, t, i) {
  if (e.length > this.$buffer.length) return this.destroy(new Error("ebml:write buffer overflow."));
  var s = this.$buffer.length - this.$head;
  if (e.length > s) {
    e.copy(this.$buffer, this.$head, 0, s);
    e.copy(this.$buffer, 0, s, e.length);
    this.$head = e.length - s;
  } else {
    e.copy(this.$buffer, this.$head);
    this.$head += e.length;
  }
  try {
    this._decoder.write(e);
    i();
  } catch (e) {
    this.destroy(e);
  }
};

function MediaSegment(e, t) {
  var i = this;
  this.$etup();
  var s = e._initSegment;
  this.playtime = s.playtime;
  this.timescale = s.timescale;
  this.seektime = e._seekTime;
  this._reader = null;
  this._async(function() {
    i._reader = e._createReader(t, i, "cluster", function(e) {
      if (!i.destroyed) if (e) i.append.apply(i, arguments); else {
        d > 1 && console.debug(i + " EOS", null === e);
        i.push(null);
        i.destroy();
      }
    });
  });
}

createStream(MediaSegment, stream.PassThrough, function(e) {
  if (this._reader) {
    this._reader.destroy(e);
    this._reader = null;
  }
  this.end();
});

MediaSegment.prototype.hexdump = function(e) {
  var t = hexdump(e);
  console.log(t.slice(0, 12).join("\n") + "\n........\n" + t.slice(t.length - 4).join("\n"));
};

MediaSegment.prototype.append = function(e, t, i) {
  if (i < 0) {
    i = this.playtime / this.timescale - t;
    d && console.debug(this + " Last cluster, duration:", i);
  }
  var s = -1, r = e.readUInt32BE(4);
  if (16777216 === r) s = 12; else if (r >> 24 === 255) s = 5; else if (d) {
    console.warn("Unexpected cluster data size...");
    this.hexdump(e);
  }
  if (s > 0) if ((r = e.readUInt16BE(s)) >> 8 === 231 && (255 & r) > 127) {
    if (-(e.duration = 1) !== this.seektime) {
      e.seektime = this.seektime;
      this.seektime = -1;
    }
    var n = -65409 & r, a = s + 2;
    while (n-- > 0) e.writeUInt8(0, a++);
  } else d && console.warn("Unexpected timecode offset...");
  this.push(e);
};

function createStream(e, i, t) {
  inherits(e, i);
  e.prototype.$etup = function() {
    this.$iid = (Math.random() * Date.now() | 0).toString(16).slice(-6);
    this.destroyed = !1;
    i.call(this);
    if (d > 2) {
      var t = this.emit;
      this.emit = function(e) {
        console.warn(this + ".emit(%s)", e, arguments, [ this ]);
        return t.apply(this, arguments);
      };
    }
  };
  e.prototype._async = function(e) {
    var t = this;
    onIdle(function() {
      t.destroyed || e.call(t);
    });
  };
  t = t && tryCatch(t);
  e.prototype.destroy = function(e) {
    d && console[e ? "error" : "debug"](this + ".destroy", this.destroyed, [ this ], e);
    if (!this.destroyed) {
      this.destroyed = !0;
      t && t.call(this, e);
      e && this.emit("error", e);
      this.emit("close");
    }
  };
  e.prototype.toString = function() {
    return this.constructor.name + "[$" + this.$iid + "]";
  };
}

function tryCatch(e) {
  e.$trycatcher = function() {
    try {
      return e.apply(this, arguments);
    } catch (e) {
      console.warn("Unexpected caught exception.", e);
    }
  };
  return e.$trycatcher;
}

function hexdump(e, t, i) {
  t = t || 0;
  i = i || e.length;
  for (var s = [], r = "", n = 0; n < i; n += 16) {
    r = ("0000000" + t.toString(16).toUpperCase()).slice(-8) + ":  ";
    for (var a = Math.min(16, i - t), o = "", h = 0; h < 16; ++h) {
      !h || h % 4 || (r += " ");
      if (h < a) {
        var u = e.readUInt8(t);
        o += u > 31 && u < 127 ? String.fromCharCode(u) : ".";
        r += ("0" + u.toString(16).toUpperCase()).slice(-2);
        t++;
      } else {
        r += "  ";
        o += " ";
      }
    }
    s.push(r + "  " + o);
  }
  return s;
}
},{"/bundle/utils":3,"buffer":8,"ebml/lib/ebml/decoder":9,"eventemitter3":13,"readable-stream":35}],5:[function(require,module,exports){
var bs = require("binary-search"), EventEmitter = require("eventemitter3").EventEmitter, inherits = require("/bundle/utils").inherit, mp4 = require("mp4-stream"), Box = require("mp4-box-encoding"), RangeSliceStream = require("range-slice-stream"), Buffer = require("buffer").Buffer;

function MP4Remuxer(e) {
  var t = this;
  EventEmitter.call(t);
  t._tracks = [];
  t._fragmentSequence = 1;
  t._file = e;
  t._decoder = null;
  t._findMoov(0);
}

inherits(module.exports = MP4Remuxer, EventEmitter);

MP4Remuxer.prototype._parseMoov = function() {
  var t = this, e = t._moov, r = t._sidx;
  if (e) {
    t._moov = t._sidx = !1;
    t._decoder && t._decoder.destroy();
    try {
      if (r) for (var s = e.traks.length; s--; ) {
        var a = e.traks[s];
        if (a.tkhd.trackId === r.referenceId) {
          a.sidx = r;
          break;
        }
      }
      t._processMoov(e);
    } catch (e) {
      t.emit("error", e);
    }
  }
};

MP4Remuxer.prototype._findMoov = function(e) {
  var s = this, t = this._file, a = {
    moov: 1,
    sidx: 1
  }, n = "sidx";
  if (!(d > 11)) {
    n = "moov";
    delete a.sidx;
  }
  if (t.filesize >= 0 && e >= t.filesize) return s._moov ? s._parseMoov() : s.emit("error", RangeError("Offset out of bound."));
  var i = t.createReadStream({
    start: e
  });
  s._decoder = mp4.decode();
  i.pipe(s._decoder);
  s._decoder.once("box", function(t) {
    var r = function() {
      s._decoder.destroy();
      s["_" + n] ? s._parseMoov() : s._findMoov(e + t.length);
    };
    i.destroy();
    d && console.debug("box", t.type, t.length, t, e);
    a[t.type] ? s._decoder.decode(function(e) {
      s["_" + t.type] = e;
      r();
    }) : r();
  });
};

function RunLengthIndex(e, t) {
  var r = this;
  r._entries = e;
  r._countName = t || "count";
  r._index = 0;
  r._offset = 0;
  r.value = r._entries[0] || !1;
}

RunLengthIndex.prototype.inc = function() {
  var e = this;
  e._offset++;
  if (e._offset >= e._entries[e._index][e._countName]) {
    e._index++;
    e._offset = 0;
  }
  e.value = e._entries[e._index] || !1;
};

MP4Remuxer.prototype._processMoov = function(e) {
  var t = this, r = {
    "mp4a.6b": 1,
    "mp4a.69": 1
  }, s = e.traks;
  t._tracks = [];
  t._hasVideo = !1;
  t._hasAudio = !1;
  for (var a = 0; a < s.length; a++) {
    var n, i, o = s[a], m = o.mdia.minf.stbl, f = m.stco || m.co64, u = m.stsd.entries[0], c = o.mdia.hdlr.handlerType;
    d && console.debug("handler=%s, type=%s, trak:", c, u.type, o);
    if (t._hasVideo || "vide" !== c || "avc1" !== u.type) {
      if (t._hasAudio || "soun" !== c) continue;
      if ("mp4a" === u.type) {
        n = "mp4a";
        u.esds && u.esds.mimeCodec && (n += "." + u.esds.mimeCodec);
        r[n] && (n = "mp3");
      } else n = "fLaC" === u.type ? "flac" : u.type;
      i = (i = 'audio/mp4; codecs="%"').replace("%", n);
      d && console.debug(i);
      if (!MediaSource.isTypeSupported(i) && ("mp3" !== n || !MediaSource.isTypeSupported(i = "audio/mpeg"))) {
        t._hasUnsupportedAudio = n;
        continue;
      }
      t._hasAudio = n;
    } else {
      n = "avc1";
      u.avcC && (n += "." + u.avcC.mimeCodec);
      i = 'video/mp4; codecs="' + n + '"';
      d && console.debug(i);
      t._hasVideo = n;
    }
    var l, p = [], h = 0, v = 0, _ = 0, g = 0, y = 0, x = 0, S = new RunLengthIndex(m.stts.entries), k = null;
    m.ctts && (k = new RunLengthIndex(m.ctts.entries));
    var M = 0;
    if (S.value) {
      while (1) {
        l = m.stsc.entries[y];
        var b = m.stsz.entries[h], I = S.value && S.value.duration || 0, R = !0;
        m.stss && (R = m.stss.entries[M] === h + 1);
        p.push({
          size: b,
          duration: I,
          dts: x,
          presentationOffset: k && k.value.compositionOffset || 0,
          sync: R,
          offset: g + f.entries[_]
        });
        if (++h >= m.stsz.entries.length) break;
        g += b;
        if (++v >= l.samplesPerChunk) {
          g = v = 0;
          _++;
          var B = m.stsc.entries[y + 1];
          B && _ + 1 >= B.firstChunk && y++;
        }
        x += I;
        S.inc();
        k && k.inc();
        R && M++;
      }
      o.mdia.mdhd.duration = 0;
      o.tkhd.duration = 0;
      var E = l && l.sampleDescriptionId || 0, w = {
        type: "moov",
        mvhd: e.mvhd,
        traks: [ {
          tkhd: o.tkhd,
          mdia: {
            mdhd: o.mdia.mdhd,
            hdlr: o.mdia.hdlr,
            elng: o.mdia.elng,
            minf: {
              vmhd: o.mdia.minf.vmhd,
              smhd: o.mdia.minf.smhd,
              dinf: o.mdia.minf.dinf,
              stbl: {
                stsd: m.stsd,
                stts: empty(),
                ctts: empty(),
                stsc: empty(),
                stsz: empty(),
                stco: empty(),
                stss: empty()
              }
            }
          }
        } ],
        mvex: {
          mehd: {
            fragmentDuration: e.mvhd.duration
          },
          trexs: [ {
            trackId: o.tkhd.trackId,
            defaultSampleDescriptionIndex: E,
            defaultSampleDuration: 0,
            defaultSampleSize: 0,
            defaultSampleFlags: 0
          } ]
        }
      };
      t._tracks.push({
        trackId: o.tkhd.trackId,
        timeScale: o.mdia.mdhd.timeScale,
        samples: p,
        currSample: null,
        currTime: null,
        moov: w,
        mime: i
      });
    } else console.warn("No 'stts' entries for trak %s...", a, o);
  }
  if (0 !== t._tracks.length) {
    t._ftyp = {
      type: "ftyp",
      brand: "iso5",
      brandVersion: e.mvhd.duration = 0,
      compatibleBrands: [ "iso5" ]
    };
    var z = Box.encode(t._ftyp), O = t._tracks.map(function(e) {
      var t = Box.encode(e.moov);
      return {
        mime: e.mime,
        init: Buffer.concat([ z, t ])
      };
    });
    t.emit("ready", O);
  } else t.emit("error", new Error("no playable tracks"));
};

function empty() {
  return {
    version: 0,
    flags: 0,
    entries: []
  };
}

MP4Remuxer.prototype._writeFragment = function(r, e) {
  var s = this, t = s._tracks[e], a = t.inStream, n = t.outStream, i = function(t) {
    return function(e) {
      e ? s.emit("error", e) : n.destroyed || a.destroyed ? d > 1 && console.debug("writeFragment stream destroyed", n.destroyed, a.destroyed) : t();
    };
  }, o = i(function() {
    if (!(r = s._generateFragment(e))) return n.finalize();
    f();
  }), m = i(function() {
    var e = a.slice(r.ranges), t = n.mediaData(r.length, o);
    e.pipe(t);
  }), f = function() {
    n.destroyed || n.box(r.moof, m);
  };
  f();
};

MP4Remuxer.prototype.seek = function(s) {
  var a = this;
  if (!a._tracks) throw new Error("Not ready yet; wait for 'ready' event");
  if (a._fileStream) {
    a._fileStream.destroy();
    a._fileStream = null;
  }
  var n = 0, i = Math.pow(2, 53);
  a._tracks.forEach(function(e, t) {
    e.fragment = a._generateFragment(t, s);
    if (e.fragment) {
      var r = e.fragment.ranges[0].start;
      i = Math.min(i, r);
      n = n ? Math.abs(n - r) : r;
    }
  });
  if (d) {
    console.debug("MP4Remuxer: Measured highWaterMark to need %s bytes.", n);
    n > 1e7 && console.warn("^ excessive highWaterMark detected...");
  }
  n = n + 16777216 & -16777216;
  return a._tracks.map(function(e, t) {
    e.outStream && e.outStream.destroy();
    if (e.inStream) {
      e.inStream.destroy();
      e.inStream = null;
    }
    e.outStream = mp4.encode();
    if (e.fragment) {
      d && console.debug("MP4Remuxer.seek(%s)", s, e, i);
      e.inStream = new RangeSliceStream(i, {
        highWaterMark: n
      });
      a._fileStream || (a._fileStream = a._file.createReadStream({
        start: i
      }));
      a._fileStream.pipe(e.inStream);
      a._writeFragment(e.fragment, t);
    } else e.outStream.finalize();
    return e.outStream;
  });
};

MP4Remuxer.prototype._findSampleBefore = function(e, t) {
  var r = this._tracks[e], s = Math.floor(r.timeScale * t), a = bs(r.samples, s, function(e, t) {
    return e.dts + e.presentationOffset - t;
  });
  -1 === a ? a = 0 : a < 0 && (a = -a - 2);
  if (a < 1) return 0;
  var n = a;
  while (!r.samples[a].sync) if (--a < 0) return n;
  return a;
};

var MIN_FRAGMENT_DURATION = 1;

MP4Remuxer.prototype._generateFragment = function(e, t) {
  var r, s = this._tracks[e];
  if ((r = void 0 !== t ? this._findSampleBefore(e, t) : s.currSample) >= s.samples.length) return null;
  for (var a = s.samples[r].dts, n = 0, i = [], o = r; o < s.samples.length; o++) {
    var d = s.samples[o];
    if (d.sync && d.dts - a >= s.timeScale * MIN_FRAGMENT_DURATION) break;
    n += d.size;
    var m = i.length - 1;
    m < 0 || i[m].end !== d.offset ? i.push({
      start: d.offset,
      end: d.offset + d.size
    }) : i[m].end += d.size;
  }
  return {
    moof: this._generateMoof(e, r, s.currSample = o),
    ranges: i,
    length: n
  };
};

MP4Remuxer.prototype._generateMoof = function(e, t, r) {
  for (var s = this._tracks[e], a = [], n = t; n < r; n++) {
    var i = s.samples[n];
    a.push({
      sampleDuration: i.duration,
      sampleSize: i.size,
      sampleFlags: i.sync ? 33554432 : 16842752,
      sampleCompositionTimeOffset: i.presentationOffset
    });
  }
  var o = {
    type: "moof",
    mfhd: {
      sequenceNumber: this._fragmentSequence++
    },
    trafs: [ {
      tfhd: {
        flags: 131072,
        trackId: s.trackId
      },
      tfdt: {
        baseMediaDecodeTime: s.samples[t].dts
      },
      trun: {
        flags: 3841,
        dataOffset: 8,
        entries: a
      }
    } ]
  };
  o.trafs[0].trun.dataOffset += Box.encodingLength(o);
  return o;
};

var UINT32_MAX = Math.pow(2, 32);

Box.boxes.fullBoxes.co64 = !0;

Box.boxes.co64 = {};

Box.boxes.co64.decode = function(e, t) {
  for (var r = (e = e.slice(t)).readUInt32BE(0), s = new Array(r), a = 0; a < r; a++) {
    var n = 8 * a + 4, i = e.readUInt32BE(n), o = e.readUInt32BE(n + 4);
    s[a] = i * UINT32_MAX + o;
  }
  return {
    entries: s
  };
};

Box.boxes.fullBoxes.sidx = !0;

Box.boxes.sidx = {};

Box.boxes.sidx.decode = function(t, e) {
  var r, s = Object.create(null), a = e + 4, n = function() {
    var e = t.readUInt16BE(a);
    a += 2;
    return e;
  }, i = function() {
    var e = t.readUInt32BE(a);
    a += 4;
    return e;
  }, o = function() {
    var e = i(), t = i();
    return e * UINT32_MAX + t;
  };
  s.referenceId = i();
  s.timescale = i();
  if (0 === this.version) {
    s.earliestPresentationTime = i();
    s.firstOffset = i();
  } else {
    s.earliestPresentationTime = o();
    s.firstOffset = o();
  }
  n();
  s.count = n();
  s.entries = new Array(s.count);
  r = s.earliestPresentationTime;
  e = this.length + s.firstOffset;
  for (var d = 0; d < s.count; d++) {
    var m = s.entries[d] = Object.create(null), f = i();
    m.type = f >>> 31 & 1;
    m.size = 2147483647 & f;
    m.duration = i();
    f = i();
    m.sap = f >>> 31 & 1;
    m.sapType = f >>> 28 & 7;
    m.sapDelta = 268435455 & f;
    m.byteOffset = [ e, e + m.size - 1 ];
    m.timeOffset = [ r, r / s.timescale, m.duration / s.timescale ];
    e += m.size;
    r += m.duration;
  }
  return s;
};
},{"/bundle/utils":3,"binary-search":7,"buffer":8,"eventemitter3":13,"mp4-box-encoding":18,"mp4-stream":21,"range-slice-stream":25}],6:[function(require,module,exports){
"use strict";

exports.byteLength = byteLength;

exports.toByteArray = toByteArray;

exports.fromByteArray = fromByteArray;

for (var lookup = [], revLookup = [], Arr = "undefined" !== typeof Uint8Array ? Uint8Array : Array, code = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/", i = 0, len = code.length; i < len; ++i) {
  lookup[i] = code[i];
  revLookup[code.charCodeAt(i)] = i;
}

revLookup["-".charCodeAt(0)] = 62;

revLookup["_".charCodeAt(0)] = 63;

function getLens(o) {
  var r = o.length;
  if (r % 4 > 0) throw new Error("Invalid string. Length must be a multiple of 4");
  var e = o.indexOf("=");
  -1 === e && (e = r);
  return [ e, e === r ? 0 : 4 - e % 4 ];
}

function byteLength(o) {
  var r = getLens(o), e = r[1];
  return 3 * (r[0] + e) / 4 - e;
}

function _byteLength(o, r, e) {
  return 3 * (r + e) / 4 - e;
}

function toByteArray(o) {
  for (var r, e = getLens(o), t = e[0], n = e[1], u = new Arr(_byteLength(o, t, n)), p = 0, a = n > 0 ? t - 4 : t, i = 0; i < a; i += 4) {
    r = revLookup[o.charCodeAt(i)] << 18 | revLookup[o.charCodeAt(i + 1)] << 12 | revLookup[o.charCodeAt(i + 2)] << 6 | revLookup[o.charCodeAt(i + 3)];
    u[p++] = r >> 16 & 255;
    u[p++] = r >> 8 & 255;
    u[p++] = 255 & r;
  }
  if (2 === n) {
    r = revLookup[o.charCodeAt(i)] << 2 | revLookup[o.charCodeAt(i + 1)] >> 4;
    u[p++] = 255 & r;
  }
  if (1 === n) {
    r = revLookup[o.charCodeAt(i)] << 10 | revLookup[o.charCodeAt(i + 1)] << 4 | revLookup[o.charCodeAt(i + 2)] >> 2;
    u[p++] = r >> 8 & 255;
    u[p++] = 255 & r;
  }
  return u;
}

function tripletToBase64(o) {
  return lookup[o >> 18 & 63] + lookup[o >> 12 & 63] + lookup[o >> 6 & 63] + lookup[63 & o];
}

function encodeChunk(o, r, e) {
  for (var t = [], n = r; n < e; n += 3) t.push(tripletToBase64((o[n] << 16 & 16711680) + (o[n + 1] << 8 & 65280) + (255 & o[n + 2])));
  return t.join("");
}

function fromByteArray(o) {
  for (var r, e = o.length, t = e % 3, n = [], u = 16383, p = 0, a = e - t; p < a; p += u) n.push(encodeChunk(o, p, p + u > a ? a : p + u));
  1 === t ? n.push(lookup[(r = o[e - 1]) >> 2] + lookup[r << 4 & 63] + "==") : 2 === t && n.push(lookup[(r = (o[e - 2] << 8) + o[e - 1]) >> 10] + lookup[r >> 4 & 63] + lookup[r << 2 & 63] + "=");
  return n.join("");
}
},{}],7:[function(require,module,exports){
module.exports = function(e, r, n, i, o) {
  var l, t;
  if (void 0 === i) i = 0; else if ((i |= 0) < 0 || i >= e.length) throw new RangeError("invalid lower bound");
  if (void 0 === o) o = e.length - 1; else if ((o |= 0) < i || o >= e.length) throw new RangeError("invalid upper bound");
  while (i <= o) if ((t = +n(e[l = i + (o - i >> 1)], r, l, e)) < 0) i = l + 1; else {
    if (!(t > 0)) return l;
    o = l - 1;
  }
  return ~i;
};
},{}],8:[function(require,module,exports){
/*!
 * The buffer module from node.js, for the browser.
 *
 * @author   Feross Aboukhadijeh <https://feross.org>
 * @license  MIT
 */
"use strict";

var base64 = require("base64-js"), ieee754 = require("ieee754");

exports.Buffer = Buffer;

exports.SlowBuffer = SlowBuffer;

exports.INSPECT_MAX_BYTES = 50;

var K_MAX_LENGTH = 2147483647;

exports.kMaxLength = K_MAX_LENGTH;

Buffer.TYPED_ARRAY_SUPPORT = typedArraySupport();

Buffer.TYPED_ARRAY_SUPPORT || "undefined" === typeof console || "function" !== typeof console.error || console.error("This browser lacks typed array (Uint8Array) support which is required by `buffer` v5.x. Use `buffer` v4.x if you require old browser support.");

function typedArraySupport() {
  try {
    var r = new Uint8Array(1);
    r.__proto__ = {
      __proto__: Uint8Array.prototype,
      foo: function() {
        return 42;
      }
    };
    return 42 === r.foo();
  } catch (r) {
    return !1;
  }
}

Object.defineProperty(Buffer.prototype, "parent", {
  get: function() {
    if (this instanceof Buffer) return this.buffer;
  }
});

Object.defineProperty(Buffer.prototype, "offset", {
  get: function() {
    if (this instanceof Buffer) return this.byteOffset;
  }
});

function createBuffer(r) {
  if (r > K_MAX_LENGTH) throw new RangeError("Invalid typed array length");
  var e = new Uint8Array(r);
  e.__proto__ = Buffer.prototype;
  return e;
}

function Buffer(r, e, t) {
  if ("number" === typeof r) {
    if ("string" === typeof e) throw new Error("If encoding is specified then the first argument must be a string");
    return allocUnsafe(r);
  }
  return from(r, e, t);
}

"undefined" !== typeof Symbol && Symbol.species && Buffer[Symbol.species] === Buffer && Object.defineProperty(Buffer, Symbol.species, {
  value: null,
  configurable: !0,
  enumerable: !1,
  writable: !1
});

Buffer.poolSize = 8192;

function from(r, e, t) {
  if ("number" === typeof r) throw new TypeError('"value" argument must not be a number');
  return isArrayBuffer(r) || r && isArrayBuffer(r.buffer) ? fromArrayBuffer(r, e, t) : "string" === typeof r ? fromString(r, e) : fromObject(r);
}

Buffer.from = function(r, e, t) {
  return from(r, e, t);
};

Buffer.prototype.__proto__ = Uint8Array.prototype;

Buffer.__proto__ = Uint8Array;

function alloc(r, e, t) {
  return r <= 0 ? createBuffer(r) : void 0 !== e ? "string" === typeof t ? createBuffer(r).fill(e, t) : createBuffer(r).fill(e) : createBuffer(r);
}

Buffer.alloc = function(r, e, t) {
  return alloc(r, e, t);
};

function allocUnsafe(r) {
  return createBuffer(r < 0 ? 0 : 0 | r);
}

Buffer.allocUnsafe = function(r) {
  return allocUnsafe(r);
};

Buffer.allocUnsafeSlow = function(r) {
  return allocUnsafe(r);
};

function fromString(r, e) {
  "string" === typeof e && "" !== e || (e = "utf8");
  if (!Buffer.isEncoding(e)) throw new TypeError("Unknown encoding: " + e);
  var t = 0 | byteLength(r, e), n = createBuffer(t), f = n.write(r, e);
  f !== t && (n = n.slice(0, f));
  return n;
}

function fromArrayLike(r) {
  for (var e = r.length < 0 ? 0 : 0 | r.length, t = createBuffer(e), n = 0; n < e; n += 1) t[n] = 255 & r[n];
  return t;
}

function fromArrayBuffer(r, e, t) {
  if (e < 0 || r.byteLength < e) throw new RangeError('"offset" is outside of buffer bounds');
  if (r.byteLength < e + (t || 0)) throw new RangeError('"length" is outside of buffer bounds');
  var n;
  (n = void 0 === e && void 0 === t ? new Uint8Array(r) : void 0 === t ? new Uint8Array(r, e) : new Uint8Array(r, e, t)).__proto__ = Buffer.prototype;
  return n;
}

function fromObject(r) {
  if (Buffer.isBuffer(r)) {
    var e = 0 | r.length, t = createBuffer(e);
    if (0 === t.length) return t;
    r.copy(t, 0, 0, e);
    return t;
  }
  if (r) {
    if (ArrayBuffer.isView(r) || "length" in r) return "number" !== typeof r.length || numberIsNaN(r.length) ? createBuffer(0) : fromArrayLike(r);
    if ("Buffer" === r.type && Array.isArray(r.data)) return fromArrayLike(r.data);
  }
  throw new TypeError("The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object.");
}

function SlowBuffer(r) {
  +r != r && (r = 0);
  return Buffer.alloc(+r);
}

Buffer.isBuffer = function(r) {
  return null != r && !0 === r._isBuffer;
};

Buffer.compare = function(r, e) {
  if (!Buffer.isBuffer(r) || !Buffer.isBuffer(e)) throw new TypeError("Arguments must be Buffers");
  if (r === e) return 0;
  for (var t = r.length, n = e.length, f = 0, i = Math.min(t, n); f < i; ++f) if (r[f] !== e[f]) {
    t = r[f];
    n = e[f];
    break;
  }
  return t < n ? -1 : n < t ? 1 : 0;
};

Buffer.isEncoding = function(r) {
  switch (String(r).toLowerCase()) {
   case "hex":
   case "utf8":
   case "utf-8":
   case "ascii":
   case "latin1":
   case "binary":
   case "base64":
   case "ucs2":
   case "ucs-2":
   case "utf16le":
   case "utf-16le":
    return !0;

   default:
    return !1;
  }
};

Buffer.concat = function(r, e) {
  if (!Array.isArray(r)) throw new TypeError('"list" argument must be an Array of Buffers');
  if (0 === r.length) return Buffer.alloc(0);
  var t;
  if (void 0 === e) for (t = e = 0; t < r.length; ++t) e += r[t].length;
  var n = Buffer.allocUnsafe(e), f = 0;
  for (t = 0; t < r.length; ++t) {
    var i = r[t];
    ArrayBuffer.isView(i) && (i = Buffer.from(i));
    if (!Buffer.isBuffer(i)) throw new TypeError('"list" argument must be an Array of Buffers');
    i.copy(n, f);
    f += i.length;
  }
  return n;
};

function byteLength(r, e) {
  if (Buffer.isBuffer(r)) return r.length;
  if (ArrayBuffer.isView(r) || isArrayBuffer(r)) return r.byteLength;
  "string" !== typeof r && (r = "" + r);
  var t = r.length;
  if (0 === t) return 0;
  for (var n = !1; ;) switch (e) {
   case "ascii":
   case "latin1":
   case "binary":
    return t;

   case "utf8":
   case "utf-8":
   case void 0:
    return utf8ToBytes(r).length;

   case "ucs2":
   case "ucs-2":
   case "utf16le":
   case "utf-16le":
    return 2 * t;

   case "hex":
    return t >>> 1;

   case "base64":
    return base64ToBytes(r).length;

   default:
    if (n) return utf8ToBytes(r).length;
    e = ("" + e).toLowerCase();
    n = !0;
  }
}

Buffer.byteLength = byteLength;

function slowToString(r, e, t) {
  var n = !1;
  (void 0 === e || e < 0) && (e = 0);
  if (e > this.length) return "";
  (void 0 === t || t > this.length) && (t = this.length);
  if (t <= 0) return "";
  if ((t >>>= 0) <= (e >>>= 0)) return "";
  r || (r = "utf8");
  while (1) switch (r) {
   case "hex":
    return hexSlice(this, e, t);

   case "utf8":
   case "utf-8":
    return utf8Slice(this, e, t);

   case "ascii":
    return asciiSlice(this, e, t);

   case "latin1":
   case "binary":
    return latin1Slice(this, e, t);

   case "base64":
    return base64Slice(this, e, t);

   case "ucs2":
   case "ucs-2":
   case "utf16le":
   case "utf-16le":
    return utf16leSlice(this, e, t);

   default:
    if (n) throw new TypeError("Unknown encoding: " + r);
    r = (r + "").toLowerCase();
    n = !0;
  }
}

Buffer.prototype._isBuffer = !0;

function swap(r, e, t) {
  var n = r[e];
  r[e] = r[t];
  r[t] = n;
}

Buffer.prototype.swap16 = function() {
  var r = this.length;
  if (r % 2 !== 0) throw new RangeError("Buffer size must be a multiple of 16-bits");
  for (var e = 0; e < r; e += 2) swap(this, e, e + 1);
  return this;
};

Buffer.prototype.swap32 = function() {
  var r = this.length;
  if (r % 4 !== 0) throw new RangeError("Buffer size must be a multiple of 32-bits");
  for (var e = 0; e < r; e += 4) {
    swap(this, e, e + 3);
    swap(this, e + 1, e + 2);
  }
  return this;
};

Buffer.prototype.swap64 = function() {
  var r = this.length;
  if (r % 8 !== 0) throw new RangeError("Buffer size must be a multiple of 64-bits");
  for (var e = 0; e < r; e += 8) {
    swap(this, e, e + 7);
    swap(this, e + 1, e + 6);
    swap(this, e + 2, e + 5);
    swap(this, e + 3, e + 4);
  }
  return this;
};

Buffer.prototype.toString = function() {
  var r = this.length;
  return 0 === r ? "" : 0 === arguments.length ? utf8Slice(this, 0, r) : slowToString.apply(this, arguments);
};

Buffer.prototype.toLocaleString = Buffer.prototype.toString;

Buffer.prototype.equals = function(r) {
  if (!Buffer.isBuffer(r)) throw new TypeError("Argument must be a Buffer");
  return this === r || 0 === Buffer.compare(this, r);
};

Buffer.prototype.inspect = function() {
  var r = "", e = exports.INSPECT_MAX_BYTES;
  if (this.length > 0) {
    r = this.toString("hex", 0, e).match(/.{2}/g).join(" ");
    this.length > e && (r += " ... ");
  }
  return "<Buffer " + r + ">";
};

Buffer.prototype.compare = function(r, e, t, n, f) {
  if (!Buffer.isBuffer(r)) throw new TypeError("Argument must be a Buffer");
  void 0 === e && (e = 0);
  void 0 === t && (t = r ? r.length : 0);
  void 0 === n && (n = 0);
  void 0 === f && (f = this.length);
  if (e < 0 || t > r.length || n < 0 || f > this.length) throw new RangeError("out of range index");
  if (n >= f && e >= t) return 0;
  if (n >= f) return -1;
  if (e >= t) return 1;
  if (this === r) return 0;
  for (var i = (f >>>= 0) - (n >>>= 0), o = (t >>>= 0) - (e >>>= 0), u = Math.min(i, o), s = this.slice(n, f), a = r.slice(e, t), h = 0; h < u; ++h) if (s[h] !== a[h]) {
    i = s[h];
    o = a[h];
    break;
  }
  return i < o ? -1 : o < i ? 1 : 0;
};

function bidirectionalIndexOf(r, e, t, n, f) {
  if (0 === r.length) return -1;
  if ("string" === typeof t) {
    n = t;
    t = 0;
  } else t > 2147483647 ? t = 2147483647 : t < -2147483648 && (t = -2147483648);
  numberIsNaN(t = +t) && (t = f ? 0 : r.length - 1);
  t < 0 && (t = r.length + t);
  if (t >= r.length) {
    if (f) return -1;
    t = r.length - 1;
  } else if (t < 0) {
    if (!f) return -1;
    t = 0;
  }
  "string" === typeof e && (e = Buffer.from(e, n));
  if (Buffer.isBuffer(e)) return 0 === e.length ? -1 : arrayIndexOf(r, e, t, n, f);
  if ("number" === typeof e) {
    e &= 255;
    return "function" === typeof Uint8Array.prototype.indexOf ? f ? Uint8Array.prototype.indexOf.call(r, e, t) : Uint8Array.prototype.lastIndexOf.call(r, e, t) : arrayIndexOf(r, [ e ], t, n, f);
  }
  throw new TypeError("val must be string, number or Buffer");
}

function arrayIndexOf(r, e, t, n, f) {
  var i, o = 1, u = r.length, s = e.length;
  if (void 0 !== n && ("ucs2" === (n = String(n).toLowerCase()) || "ucs-2" === n || "utf16le" === n || "utf-16le" === n)) {
    if (r.length < 2 || e.length < 2) return -1;
    u /= o = 2;
    s /= 2;
    t /= 2;
  }
  function read(r, e) {
    return 1 === o ? r[e] : r.readUInt16BE(e * o);
  }
  if (f) {
    var a = -1;
    for (i = t; i < u; i++) if (read(r, i) === read(e, -1 === a ? 0 : i - a)) {
      -1 === a && (a = i);
      if (i - a + 1 === s) return a * o;
    } else {
      -1 !== a && (i -= i - a);
      a = -1;
    }
  } else {
    t + s > u && (t = u - s);
    for (i = t; i >= 0; i--) {
      for (var h = !0, c = 0; c < s; c++) if (read(r, i + c) !== read(e, c)) {
        h = !1;
        break;
      }
      if (h) return i;
    }
  }
  return -1;
}

Buffer.prototype.includes = function(r, e, t) {
  return -1 !== this.indexOf(r, e, t);
};

Buffer.prototype.indexOf = function(r, e, t) {
  return bidirectionalIndexOf(this, r, e, t, !0);
};

Buffer.prototype.lastIndexOf = function(r, e, t) {
  return bidirectionalIndexOf(this, r, e, t, !1);
};

function hexWrite(r, e, t, n) {
  t = Number(t) || 0;
  var f = r.length - t;
  n ? (n = Number(n)) > f && (n = f) : n = f;
  var i = e.length;
  n > i / 2 && (n = i / 2);
  for (var o = 0; o < n; ++o) {
    var u = parseInt(e.substr(2 * o, 2), 16);
    if (numberIsNaN(u)) return o;
    r[t + o] = u;
  }
  return o;
}

function utf8Write(r, e, t, n) {
  return blitBuffer(utf8ToBytes(e, r.length - t), r, t, n);
}

function asciiWrite(r, e, t, n) {
  return blitBuffer(asciiToBytes(e), r, t, n);
}

function latin1Write(r, e, t, n) {
  return asciiWrite(r, e, t, n);
}

function base64Write(r, e, t, n) {
  return blitBuffer(base64ToBytes(e), r, t, n);
}

function ucs2Write(r, e, t, n) {
  return blitBuffer(utf16leToBytes(e, r.length - t), r, t, n);
}

Buffer.prototype.write = function(r, e, t, n) {
  if (void 0 === e) {
    n = "utf8";
    t = this.length;
    e = 0;
  } else if (void 0 === t && "string" === typeof e) {
    n = e;
    t = this.length;
    e = 0;
  } else {
    if (!isFinite(e)) throw new Error("Buffer.write(string, encoding, offset[, length]) is no longer supported");
    e >>>= 0;
    if (isFinite(t)) {
      t >>>= 0;
      void 0 === n && (n = "utf8");
    } else {
      n = t;
      t = void 0;
    }
  }
  var f = this.length - e;
  (void 0 === t || t > f) && (t = f);
  if (r.length > 0 && (t < 0 || e < 0) || e > this.length) throw new RangeError("Attempt to write outside buffer bounds");
  n || (n = "utf8");
  for (var i = !1; ;) switch (n) {
   case "hex":
    return hexWrite(this, r, e, t);

   case "utf8":
   case "utf-8":
    return utf8Write(this, r, e, t);

   case "ascii":
    return asciiWrite(this, r, e, t);

   case "latin1":
   case "binary":
    return latin1Write(this, r, e, t);

   case "base64":
    return base64Write(this, r, e, t);

   case "ucs2":
   case "ucs-2":
   case "utf16le":
   case "utf-16le":
    return ucs2Write(this, r, e, t);

   default:
    if (i) throw new TypeError("Unknown encoding: " + n);
    n = ("" + n).toLowerCase();
    i = !0;
  }
};

Buffer.prototype.toJSON = function() {
  return {
    type: "Buffer",
    data: Array.prototype.slice.call(this._arr || this, 0)
  };
};

function base64Slice(r, e, t) {
  return base64.fromByteArray(0 === e && t === r.length ? r : r.slice(e, t));
}

function utf8Slice(r, e, t) {
  t = Math.min(r.length, t);
  var n = [], f = e;
  while (f < t) {
    var i = r[f], o = null, u = i > 239 ? 4 : i > 223 ? 3 : i > 191 ? 2 : 1;
    if (f + u <= t) {
      var s, a, h, c;
      switch (u) {
       case 1:
        i < 128 && (o = i);
        break;

       case 2:
        128 === (192 & (s = r[f + 1])) && (c = (31 & i) << 6 | 63 & s) > 127 && (o = c);
        break;

       case 3:
        a = r[f + 2];
        128 === (192 & (s = r[f + 1])) && 128 === (192 & a) && (c = (15 & i) << 12 | (63 & s) << 6 | 63 & a) > 2047 && (c < 55296 || c > 57343) && (o = c);
        break;

       case 4:
        a = r[f + 2];
        h = r[f + 3];
        128 === (192 & (s = r[f + 1])) && 128 === (192 & a) && 128 === (192 & h) && (c = (15 & i) << 18 | (63 & s) << 12 | (63 & a) << 6 | 63 & h) > 65535 && c < 1114112 && (o = c);
      }
    }
    if (null === o) {
      o = 65533;
      u = 1;
    } else if (o > 65535) {
      n.push((o -= 65536) >>> 10 & 1023 | 55296);
      o = 56320 | 1023 & o;
    }
    n.push(o);
    f += u;
  }
  return decodeCodePointsArray(n);
}

var _, MAX_ARGUMENTS_LENGTH = 4096;

function decodeCodePointsArray(r) {
  var e = r.length;
  if (e <= MAX_ARGUMENTS_LENGTH) return String.fromCharCode.apply(String, r);
  var t = "", n = 0;
  while (n < e) t += String.fromCharCode.apply(String, r.slice(n, n += MAX_ARGUMENTS_LENGTH));
  return t;
}

function asciiSlice(r, e, t) {
  var n = "";
  t = Math.min(r.length, t);
  for (var f = e; f < t; ++f) n += String.fromCharCode(127 & r[f]);
  return n;
}

function latin1Slice(r, e, t) {
  var n = "";
  t = Math.min(r.length, t);
  for (var f = e; f < t; ++f) n += String.fromCharCode(r[f]);
  return n;
}

function hexSlice(r, e, t) {
  var n = r.length;
  (!e || e < 0) && (e = 0);
  (!t || t < 0 || t > n) && (t = n);
  for (var f = "", i = e; i < t; ++i) f += toHex(r[i]);
  return f;
}

function utf16leSlice(r, e, t) {
  for (var n = r.slice(e, t), f = "", i = 0; i < n.length; i += 2) f += String.fromCharCode(n[i] + 256 * n[i + 1]);
  return f;
}

Buffer.prototype.slice = function(r, e) {
  var t = this.length;
  (r = ~~r) < 0 ? (r += t) < 0 && (r = 0) : r > t && (r = t);
  (e = void 0 === e ? t : ~~e) < 0 ? (e += t) < 0 && (e = 0) : e > t && (e = t);
  e < r && (e = r);
  var n = this.subarray(r, e);
  n.__proto__ = Buffer.prototype;
  return n;
};

Buffer.prototype.readUIntLE = function(r, e, t) {
  e >>>= 0;
  var n = this[r >>>= 0], f = 1, i = 0;
  while (++i < e && (f *= 256)) n += this[r + i] * f;
  return n;
};

Buffer.prototype.readUIntBE = function(r, e, t) {
  e >>>= 0;
  var n = this[(r >>>= 0) + --e], f = 1;
  while (e > 0 && (f *= 256)) n += this[r + --e] * f;
  return n;
};

Buffer.prototype.readUInt8 = function(r, e) {
  return this[r >>>= 0];
};

Buffer.prototype.readUInt16LE = function(r, e) {
  return this[r >>>= 0] | this[r + 1] << 8;
};

Buffer.prototype.readUInt16BE = function(r, e) {
  return this[r >>>= 0] << 8 | this[r + 1];
};

Buffer.prototype.readUInt32LE = function(r, e) {
  return (this[r >>>= 0] | this[r + 1] << 8 | this[r + 2] << 16) + 16777216 * this[r + 3];
};

Buffer.prototype.readUInt32BE = function(r, e) {
  return 16777216 * this[r >>>= 0] + (this[r + 1] << 16 | this[r + 2] << 8 | this[r + 3]);
};

Buffer.prototype.readIntLE = function(r, e, t) {
  e >>>= 0;
  var n = this[r >>>= 0], f = 1, i = 0;
  while (++i < e && (f *= 256)) n += this[r + i] * f;
  n >= (f *= 128) && (n -= Math.pow(2, 8 * e));
  return n;
};

Buffer.prototype.readIntBE = function(r, e, t) {
  var n = e >>>= 0, f = 1, i = this[(r >>>= 0) + --n];
  while (n > 0 && (f *= 256)) i += this[r + --n] * f;
  i >= (f *= 128) && (i -= Math.pow(2, 8 * e));
  return i;
};

Buffer.prototype.readInt8 = function(r, e) {
  return 128 & this[r >>>= 0] ? -1 * (255 - this[r] + 1) : this[r];
};

Buffer.prototype.readInt16LE = function(r, e) {
  var t = this[r >>>= 0] | this[r + 1] << 8;
  return 32768 & t ? 4294901760 | t : t;
};

Buffer.prototype.readInt16BE = function(r, e) {
  var t = this[1 + (r >>>= 0)] | this[r] << 8;
  return 32768 & t ? 4294901760 | t : t;
};

Buffer.prototype.readInt32LE = function(r, e) {
  return this[r >>>= 0] | this[r + 1] << 8 | this[r + 2] << 16 | this[r + 3] << 24;
};

Buffer.prototype.readInt32BE = function(r, e) {
  return this[r >>>= 0] << 24 | this[r + 1] << 16 | this[r + 2] << 8 | this[r + 3];
};

Buffer.prototype.readFloatLE = function(r, e) {
  return ieee754.read(this, r >>>= 0, !0, 23, 4);
};

Buffer.prototype.readFloatBE = function(r, e) {
  return ieee754.read(this, r >>>= 0, !1, 23, 4);
};

Buffer.prototype.readDoubleLE = function(r, e) {
  return ieee754.read(this, r >>>= 0, !0, 52, 8);
};

Buffer.prototype.readDoubleBE = function(r, e) {
  return ieee754.read(this, r >>>= 0, !1, 52, 8);
};

Buffer.prototype.writeUIntLE = function(r, e, t, n) {
  t >>>= 0;
  var f = 1, i = 0;
  this[e >>>= 0] = 255 & (r = +r);
  while (++i < t && (f *= 256)) this[e + i] = r / f & 255;
  return e + t;
};

Buffer.prototype.writeUIntBE = function(r, e, t, n) {
  var f = (t >>>= 0) - 1, i = 1;
  this[(e >>>= 0) + f] = 255 & (r = +r);
  while (--f >= 0 && (i *= 256)) this[e + f] = r / i & 255;
  return e + t;
};

Buffer.prototype.writeUInt8 = function(r, e, t) {
  this[e >>>= 0] = 255 & (r = +r);
  return e + 1;
};

Buffer.prototype.writeUInt16LE = function(r, e, t) {
  this[e >>>= 0] = 255 & (r = +r);
  this[e + 1] = r >>> 8;
  return e + 2;
};

Buffer.prototype.writeUInt16BE = function(r, e, t) {
  this[e >>>= 0] = (r = +r) >>> 8;
  this[e + 1] = 255 & r;
  return e + 2;
};

Buffer.prototype.writeUInt32LE = function(r, e, t) {
  this[3 + (e >>>= 0)] = (r = +r) >>> 24;
  this[e + 2] = r >>> 16;
  this[e + 1] = r >>> 8;
  this[e] = 255 & r;
  return e + 4;
};

Buffer.prototype.writeUInt32BE = function(r, e, t) {
  this[e >>>= 0] = (r = +r) >>> 24;
  this[e + 1] = r >>> 16;
  this[e + 2] = r >>> 8;
  this[e + 3] = 255 & r;
  return e + 4;
};

Buffer.prototype.writeIntLE = function(r, e, t, n) {
  var f = 0, i = 1, o = 0;
  this[e >>>= 0] = 255 & (r = +r);
  while (++f < t && (i *= 256)) {
    r < 0 && 0 === o && 0 !== this[e + f - 1] && (o = 1);
    this[e + f] = (r / i >> 0) - o & 255;
  }
  return e + t;
};

Buffer.prototype.writeIntBE = function(r, e, t, n) {
  var f = t - 1, i = 1, o = 0;
  this[(e >>>= 0) + f] = 255 & (r = +r);
  while (--f >= 0 && (i *= 256)) {
    r < 0 && 0 === o && 0 !== this[e + f + 1] && (o = 1);
    this[e + f] = (r / i >> 0) - o & 255;
  }
  return e + t;
};

Buffer.prototype.writeInt8 = function(r, e, t) {
  (r = +r) < 0 && (r = 255 + r + 1);
  this[e >>>= 0] = 255 & r;
  return e + 1;
};

Buffer.prototype.writeInt16LE = function(r, e, t) {
  this[e >>>= 0] = 255 & (r = +r);
  this[e + 1] = r >>> 8;
  return e + 2;
};

Buffer.prototype.writeInt16BE = function(r, e, t) {
  this[e >>>= 0] = (r = +r) >>> 8;
  this[e + 1] = 255 & r;
  return e + 2;
};

Buffer.prototype.writeInt32LE = function(r, e, t) {
  this[e >>>= 0] = 255 & (r = +r);
  this[e + 1] = r >>> 8;
  this[e + 2] = r >>> 16;
  this[e + 3] = r >>> 24;
  return e + 4;
};

Buffer.prototype.writeInt32BE = function(r, e, t) {
  (r = +r) < 0 && (r = 4294967295 + r + 1);
  this[e >>>= 0] = r >>> 24;
  this[e + 1] = r >>> 16;
  this[e + 2] = r >>> 8;
  this[e + 3] = 255 & r;
  return e + 4;
};

function writeFloat(r, e, t, n, f) {
  ieee754.write(r, e = +e, t >>>= 0, n, 23, 4);
  return t + 4;
}

Buffer.prototype.writeFloatLE = function(r, e, t) {
  return writeFloat(this, r, e, !0, t);
};

Buffer.prototype.writeFloatBE = function(r, e, t) {
  return writeFloat(this, r, e, !1, t);
};

function writeDouble(r, e, t, n, f) {
  ieee754.write(r, e = +e, t >>>= 0, n, 52, 8);
  return t + 8;
}

Buffer.prototype.writeDoubleLE = function(r, e, t) {
  return writeDouble(this, r, e, !0, t);
};

Buffer.prototype.writeDoubleBE = function(r, e, t) {
  return writeDouble(this, r, e, !1, t);
};

Buffer.prototype.copy = function(r, e, t, n) {
  if (!Buffer.isBuffer(r)) throw new TypeError("argument should be a Buffer");
  t || (t = 0);
  n || 0 === n || (n = this.length);
  e >= r.length && (e = r.length);
  e || (e = 0);
  n > 0 && n < t && (n = t);
  if (n === t) return 0;
  if (0 === r.length || 0 === this.length) return 0;
  if (e < 0) throw new RangeError("targetStart out of bounds");
  if (t < 0 || t >= this.length) throw new RangeError("Index out of range");
  if (n < 0) throw new RangeError("sourceEnd out of bounds");
  n > this.length && (n = this.length);
  r.length - e < n - t && (n = r.length - e + t);
  var f = n - t;
  if (this === r && "function" === typeof Uint8Array.prototype.copyWithin) this.copyWithin(e, t, n); else if (this === r && t < e && e < n) for (var i = f - 1; i >= 0; --i) r[i + e] = this[i + t]; else Uint8Array.prototype.set.call(r, this.subarray(t, n), e);
  return f;
};

Buffer.prototype.fill = function(r, e, t, n) {
  if ("string" === typeof r) {
    if ("string" === typeof e) {
      n = e;
      e = 0;
      t = this.length;
    } else if ("string" === typeof t) {
      n = t;
      t = this.length;
    }
    if (void 0 !== n && "string" !== typeof n) throw new TypeError("encoding must be a string");
    if ("string" === typeof n && !Buffer.isEncoding(n)) throw new TypeError("Unknown encoding: " + n);
    if (1 === r.length) {
      var f = r.charCodeAt(0);
      ("utf8" === n && f < 128 || "latin1" === n) && (r = f);
    }
  } else "number" === typeof r && (r &= 255);
  if (e < 0 || this.length < e || this.length < t) throw new RangeError("Out of range index");
  if (t <= e) return this;
  e >>>= 0;
  t = void 0 === t ? this.length : t >>> 0;
  r || (r = 0);
  var i;
  if ("number" === typeof r) for (i = e; i < t; ++i) this[i] = r; else {
    var o = Buffer.isBuffer(r) ? r : new Buffer(r, n), u = o.length;
    if (0 === u) throw new TypeError('The value "' + r + '" is invalid for argument "value"');
    for (i = 0; i < t - e; ++i) this[i + e] = o[i % u];
  }
  return this;
};

var INVALID_BASE64_RE = /[^+/0-9A-Za-z-_]/g;

function base64clean(r) {
  if ((r = (r = r.split("=")[0]).trim().replace(INVALID_BASE64_RE, "")).length < 2) return "";
  while (r.length % 4 !== 0) r += "=";
  return r;
}

function toHex(r) {
  return r < 16 ? "0" + r.toString(16) : r.toString(16);
}

function utf8ToBytes(r, e) {
  e = e || Infinity;
  for (var t, n = r.length, f = null, i = [], o = 0; o < n; ++o) {
    if ((t = r.charCodeAt(o)) > 55295 && t < 57344) {
      if (!f) {
        if (t > 56319) {
          (e -= 3) > -1 && i.push(239, 191, 189);
          continue;
        }
        if (o + 1 === n) {
          (e -= 3) > -1 && i.push(239, 191, 189);
          continue;
        }
        f = t;
        continue;
      }
      if (t < 56320) {
        (e -= 3) > -1 && i.push(239, 191, 189);
        f = t;
        continue;
      }
      t = 65536 + (f - 55296 << 10 | t - 56320);
    } else f && (e -= 3) > -1 && i.push(239, 191, 189);
    f = null;
    if (t < 128) {
      if ((e -= 1) < 0) break;
      i.push(t);
    } else if (t < 2048) {
      if ((e -= 2) < 0) break;
      i.push(t >> 6 | 192, 63 & t | 128);
    } else if (t < 65536) {
      if ((e -= 3) < 0) break;
      i.push(t >> 12 | 224, t >> 6 & 63 | 128, 63 & t | 128);
    } else {
      if (!(t < 1114112)) throw new Error("Invalid code point");
      if ((e -= 4) < 0) break;
      i.push(t >> 18 | 240, t >> 12 & 63 | 128, t >> 6 & 63 | 128, 63 & t | 128);
    }
  }
  return i;
}

function asciiToBytes(r) {
  for (var e = [], t = 0; t < r.length; ++t) e.push(255 & r.charCodeAt(t));
  return e;
}

function utf16leToBytes(r, e) {
  for (var t, n, f = [], i = 0; i < r.length; ++i) {
    if ((e -= 2) < 0) break;
    n = (t = r.charCodeAt(i)) >> 8;
    f.push(t % 256);
    f.push(n);
  }
  return f;
}

function base64ToBytes(r) {
  return base64.toByteArray(base64clean(r));
}

function blitBuffer(r, e, t, n) {
  for (var f = 0; f < n; ++f) {
    if (f + t >= e.length || f >= r.length) break;
    e[f + t] = r[f];
  }
  return f;
}

function isArrayBuffer(r) {
  return r instanceof ArrayBuffer || null != r && null != r.constructor && "ArrayBuffer" === r.constructor.name && "number" === typeof r.byteLength;
}

function numberIsNaN(r) {
  return r !== r;
}
},{"base64-js":6,"ieee754":14}],9:[function(require,module,exports){
var Buffer = require("buffer").Buffer, Transform = require("readable-stream").Transform, tools = require("./tools.js"), schema = require("./schema.js"), debug = "ebml:decoder", STATE_TAG = 1, STATE_SIZE = 2, STATE_CONTENT = 3;

function EbmlDecoder(t) {
  (t = t || {}).readableObjectMode = !0;
  Transform.call(this, t);
  this._buffer = null;
  this._tag_stack = [];
  this._state = STATE_TAG;
  this._cursor = 0;
  this._total = 0;
  this._schema = schema;
}

require("/bundle/utils").inherit(EbmlDecoder, Transform);

EbmlDecoder.prototype._transform = function(t, e, r) {
  this._buffer = null === this._buffer ? t : Buffer.concat([ this._buffer, t ]);
  while (this._cursor < this._buffer.length) {
    if (this._state === STATE_TAG && !this.readTag()) break;
    if (this._state === STATE_SIZE && !this.readSize()) break;
    if (this._state === STATE_CONTENT && !this.readContent()) break;
  }
  r();
};

EbmlDecoder.prototype.getSchemaInfo = function(t) {
  return this._schema[t] || {
    type: "unknown",
    name: "unknown"
  };
};

EbmlDecoder.prototype.readTag = function() {
  if (this._cursor >= this._buffer.length) return !1;
  var t = this._total, e = tools.readVint(this._buffer, this._cursor);
  if (null == e) return !1;
  var r = this._buffer.toString("hex", this._cursor, this._cursor + e.length);
  this._cursor += e.length;
  this._total += e.length;
  this._state = STATE_SIZE;
  var s = {
    tag: e.value,
    tagStr: r,
    type: this.getSchemaInfo(r).type,
    name: this.getSchemaInfo(r).name,
    start: t,
    end: t + e.length
  };
  this._tag_stack.push(s);
  return !0;
};

EbmlDecoder.prototype.readSize = function() {
  var t = this._tag_stack[this._tag_stack.length - 1];
  if (this._cursor >= this._buffer.length) return !1;
  var e = tools.readVint(this._buffer, this._cursor);
  if (null == e) return !1;
  this._cursor += e.length;
  this._total += e.length;
  this._state = STATE_CONTENT;
  t.dataSize = e.value;
  -1 === e.value ? t.end = -1 : t.end += e.value + e.length;
  return !0;
};

EbmlDecoder.prototype.readContent = function() {
  var t = this._tag_stack[this._tag_stack.length - 1];
  if ("m" === t.type) {
    this.push([ "start", t ]);
    this._state = STATE_TAG;
    return !0;
  }
  if (this._buffer.length < this._cursor + t.dataSize) return !1;
  var e = this._buffer.slice(this._cursor, this._cursor + t.dataSize);
  this._total += t.dataSize;
  this._state = STATE_TAG;
  this._buffer = this._buffer.slice(this._cursor + t.dataSize);
  this._cursor = 0;
  this._tag_stack.pop();
  t.data = e;
  this.push([ "tag", t ]);
  while (this._tag_stack.length > 0) {
    var r = this._tag_stack[this._tag_stack.length - 1];
    if (this._total < r.end) break;
    this.push([ "end", r ]);
    this._tag_stack.pop();
  }
  return !0;
};

module.exports = EbmlDecoder;
},{"./schema.js":10,"./tools.js":11,"/bundle/utils":3,"buffer":8,"readable-stream":35}],10:[function(require,module,exports){
var schema={80:{name:"ChapterDisplay",level:"4",type:"m",multiple:"1",minver:"1",webm:"1"},83:{name:"TrackType",level:"3",type:"u",mandatory:"1",minver:"1",range:"1-254"},85:{name:"ChapString",level:"5",type:"8",mandatory:"1",minver:"1",webm:"1"},86:{name:"CodecID",level:"3",type:"s",mandatory:"1",minver:"1"},88:{name:"FlagDefault",level:"3",type:"u",mandatory:"1",minver:"1",default:"1",range:"0-1"},89:{name:"ChapterTrackNumber",level:"5",type:"u",mandatory:"1",multiple:"1",minver:"1",webm:"0",range:"not 0"},91:{name:"ChapterTimeStart",level:"4",type:"u",mandatory:"1",minver:"1",webm:"1"},92:{name:"ChapterTimeEnd",level:"4",type:"u",minver:"1",webm:"0"},96:{name:"CueRefTime",level:"5",type:"u",mandatory:"1",minver:"2",webm:"0"},97:{name:"CueRefCluster",level:"5",type:"u",mandatory:"1",webm:"0"},98:{name:"ChapterFlagHidden",level:"4",type:"u",mandatory:"1",minver:"1",webm:"0",default:"0",range:"0-1"},4254:{name:"ContentCompAlgo",level:"6",type:"u",mandatory:"1",minver:"1",webm:"0",default:"0",br:["","","",""],del:["1 - bzlib,","2 - lzo1x"]},4255:{name:"ContentCompSettings",level:"6",type:"b",minver:"1",webm:"0"},4282:{name:"DocType",level:"1",type:"s",mandatory:"1",default:"matroska",minver:"1"},4285:{name:"DocTypeReadVersion",level:"1",type:"u",mandatory:"1",default:"1",minver:"1"},4286:{name:"EBMLVersion",level:"1",type:"u",mandatory:"1",default:"1",minver:"1"},4287:{name:"DocTypeVersion",level:"1",type:"u",mandatory:"1",default:"1",minver:"1"},4444:{name:"SegmentFamily",level:"2",type:"b",multiple:"1",minver:"1",webm:"0",bytesize:"16"},4461:{name:"DateUTC",level:"2",type:"d",minver:"1"},4484:{name:"TagDefault",level:"4",type:"u",mandatory:"1",minver:"1",webm:"0",default:"1",range:"0-1"},4485:{name:"TagBinary",level:"4",type:"b",minver:"1",webm:"0"},4487:{name:"TagString",level:"4",type:"8",minver:"1",webm:"0"},4489:{name:"Duration",level:"2",type:"f",minver:"1",range:"> 0"},4598:{name:"ChapterFlagEnabled",level:"4",type:"u",mandatory:"1",minver:"1",webm:"0",default:"1",range:"0-1"},4660:{name:"FileMimeType",level:"3",type:"s",mandatory:"1",minver:"1",webm:"0"},4661:{name:"FileUsedStartTime",level:"3",type:"u",divx:"1"},4662:{name:"FileUsedEndTime",level:"3",type:"u",divx:"1"},4675:{name:"FileReferral",level:"3",type:"b",webm:"0"},5031:{name:"ContentEncodingOrder",level:"5",type:"u",mandatory:"1",minver:"1",webm:"0",default:"0"},5032:{name:"ContentEncodingScope",level:"5",type:"u",mandatory:"1",minver:"1",webm:"0",default:"1",range:"not 0",br:["","",""]},5033:{name:"ContentEncodingType",level:"5",type:"u",mandatory:"1",minver:"1",webm:"0",default:"0",br:["",""]},5034:{name:"ContentCompression",level:"5",type:"m",minver:"1",webm:"0"},5035:{name:"ContentEncryption",level:"5",type:"m",minver:"1",webm:"0"},5378:{name:"CueBlockNumber",level:"4",type:"u",minver:"1",default:"1",range:"not 0"},5654:{name:"ChapterStringUID",level:"4",type:"8",mandatory:"0",minver:"3",webm:"1"},5741:{name:"WritingApp",level:"2",type:"8",mandatory:"1",minver:"1"},5854:{name:"SilentTracks",level:"2",type:"m",minver:"1",webm:"0"},6240:{name:"ContentEncoding",level:"4",type:"m",mandatory:"1",multiple:"1",minver:"1",webm:"0"},6264:{name:"BitDepth",level:"4",type:"u",minver:"1",range:"not 0"},6532:{name:"SignedElement",level:"3",type:"b",multiple:"1",webm:"0"},6624:{name:"TrackTranslate",level:"3",type:"m",multiple:"1",minver:"1",webm:"0"},6911:{name:"ChapProcessCommand",level:"5",type:"m",multiple:"1",minver:"1",webm:"0"},6922:{name:"ChapProcessTime",level:"6",type:"u",mandatory:"1",minver:"1",webm:"0"},6924:{name:"ChapterTranslate",level:"2",type:"m",multiple:"1",minver:"1",webm:"0"},6933:{name:"ChapProcessData",level:"6",type:"b",mandatory:"1",minver:"1",webm:"0"},6944:{name:"ChapProcess",level:"4",type:"m",multiple:"1",minver:"1",webm:"0"},6955:{name:"ChapProcessCodecID",level:"5",type:"u",mandatory:"1",minver:"1",webm:"0",default:"0"},7373:{name:"Tag",level:"2",type:"m",mandatory:"1",multiple:"1",minver:"1",webm:"0"},7384:{name:"SegmentFilename",level:"2",type:"8",minver:"1",webm:"0"},7446:{name:"AttachmentLink",level:"3",type:"u",minver:"1",webm:"0",range:"not 0"},258688:{name:"CodecName",level:"3",type:"8",minver:"1"},18538067:{name:"Segment",level:"0",type:"m",mandatory:"1",multiple:"1",minver:"1"},"447a":{name:"TagLanguage",level:"4",type:"s",mandatory:"1",minver:"1",webm:"0",default:"und"},"45a3":{name:"TagName",level:"4",type:"8",mandatory:"1",minver:"1",webm:"0"},"67c8":{name:"SimpleTag",level:"3",recursive:"1",type:"m",mandatory:"1",multiple:"1",minver:"1",webm:"0"},"63c6":{name:"TagAttachmentUID",level:"4",type:"u",multiple:"1",minver:"1",webm:"0",default:"0"},"63c4":{name:"TagChapterUID",level:"4",type:"u",multiple:"1",minver:"1",webm:"0",default:"0"},"63c9":{name:"TagEditionUID",level:"4",type:"u",multiple:"1",minver:"1",webm:"0",default:"0"},"63c5":{name:"TagTrackUID",level:"4",type:"u",multiple:"1",minver:"1",webm:"0",default:"0"},"63ca":{name:"TargetType",level:"4",type:"s",minver:"1",webm:"0",strong:"informational"},"68ca":{name:"TargetTypeValue",level:"4",type:"u",minver:"1",webm:"0",default:"50"},"63c0":{name:"Targets",level:"3",type:"m",mandatory:"1",minver:"1",webm:"0"},"1254c367":{name:"Tags",level:"1",type:"m",multiple:"1",minver:"1",webm:"0"},"450d":{name:"ChapProcessPrivate",level:"5",type:"b",minver:"1",webm:"0"},"437e":{name:"ChapCountry",level:"5",type:"s",multiple:"1",minver:"1",webm:"0"},"437c":{name:"ChapLanguage",level:"5",type:"s",mandatory:"1",multiple:"1",minver:"1",webm:"1",default:"eng"},"8f":{name:"ChapterTrack",level:"4",type:"m",minver:"1",webm:"0"},"63c3":{name:"ChapterPhysicalEquiv",level:"4",type:"u",minver:"1",webm:"0"},"6ebc":{name:"ChapterSegmentEditionUID",level:"4",type:"u",minver:"1",webm:"0",range:"not 0"},"6e67":{name:"ChapterSegmentUID",level:"4",type:"b",minver:"1",webm:"0",range:">0",bytesize:"16"},"73c4":{name:"ChapterUID",level:"4",type:"u",mandatory:"1",minver:"1",webm:"1",range:"not 0"},b6:{name:"ChapterAtom",level:"3",recursive:"1",type:"m",mandatory:"1",multiple:"1",minver:"1",webm:"1"},"45dd":{name:"EditionFlagOrdered",level:"3",type:"u",minver:"1",webm:"0",default:"0",range:"0-1"},"45db":{name:"EditionFlagDefault",level:"3",type:"u",mandatory:"1",minver:"1",webm:"0",default:"0",range:"0-1"},"45bd":{name:"EditionFlagHidden",level:"3",type:"u",mandatory:"1",minver:"1",webm:"0",default:"0",range:"0-1"},"45bc":{name:"EditionUID",level:"3",type:"u",minver:"1",webm:"0",range:"not 0"},"45b9":{name:"EditionEntry",level:"2",type:"m",mandatory:"1",multiple:"1",minver:"1",webm:"1"},"1043a770":{name:"Chapters",level:"1",type:"m",minver:"1",webm:"1"},"46ae":{name:"FileUID",level:"3",type:"u",mandatory:"1",minver:"1",webm:"0",range:"not 0"},"465c":{name:"FileData",level:"3",type:"b",mandatory:"1",minver:"1",webm:"0"},"466e":{name:"FileName",level:"3",type:"8",mandatory:"1",minver:"1",webm:"0"},"467e":{name:"FileDescription",level:"3",type:"8",minver:"1",webm:"0"},"61a7":{name:"AttachedFile",level:"2",type:"m",mandatory:"1",multiple:"1",minver:"1",webm:"0"},"1941a469":{name:"Attachments",level:"1",type:"m",minver:"1",webm:"0"},eb:{name:"CueRefCodecState",level:"5",type:"u",webm:"0",default:"0"},"535f":{name:"CueRefNumber",level:"5",type:"u",webm:"0",default:"1",range:"not 0"},db:{name:"CueReference",level:"4",type:"m",multiple:"1",minver:"2",webm:"0"},ea:{name:"CueCodecState",level:"4",type:"u",minver:"2",webm:"0",default:"0"},b2:{name:"CueDuration",level:"4",type:"u",mandatory:"0",minver:"4",webm:"0"},f0:{name:"CueRelativePosition",level:"4",type:"u",mandatory:"0",minver:"4",webm:"0"},f1:{name:"CueClusterPosition",level:"4",type:"u",mandatory:"1",minver:"1"},f7:{name:"CueTrack",level:"4",type:"u",mandatory:"1",minver:"1",range:"not 0"},b7:{name:"CueTrackPositions",level:"3",type:"m",mandatory:"1",multiple:"1",minver:"1"},b3:{name:"CueTime",level:"3",type:"u",mandatory:"1",minver:"1"},bb:{name:"CuePoint",level:"2",type:"m",mandatory:"1",multiple:"1",minver:"1"},"1c53bb6b":{name:"Cues",level:"1",type:"m",minver:"1"},"47e6":{name:"ContentSigHashAlgo",level:"6",type:"u",minver:"1",webm:"0",default:"0",br:["",""]},"47e5":{name:"ContentSigAlgo",level:"6",type:"u",minver:"1",webm:"0",default:"0",br:""},"47e4":{name:"ContentSigKeyID",level:"6",type:"b",minver:"1",webm:"0"},"47e3":{name:"ContentSignature",level:"6",type:"b",minver:"1",webm:"0"},"47e2":{name:"ContentEncKeyID",level:"6",type:"b",minver:"1",webm:"0"},"47e1":{name:"ContentEncAlgo",level:"6",type:"u",minver:"1",webm:"0",default:"0",br:""},"6d80":{name:"ContentEncodings",level:"3",type:"m",minver:"1",webm:"0"},c4:{name:"TrickMasterTrackSegmentUID",level:"3",type:"b",divx:"1",bytesize:"16"},c7:{name:"TrickMasterTrackUID",level:"3",type:"u",divx:"1"},c6:{name:"TrickTrackFlag",level:"3",type:"u",divx:"1",default:"0"},c1:{name:"TrickTrackSegmentUID",level:"3",type:"b",divx:"1",bytesize:"16"},c0:{name:"TrickTrackUID",level:"3",type:"u",divx:"1"},ed:{name:"TrackJoinUID",level:"5",type:"u",mandatory:"1",multiple:"1",minver:"3",webm:"0",range:"not 0"},e9:{name:"TrackJoinBlocks",level:"4",type:"m",minver:"3",webm:"0"},e6:{name:"TrackPlaneType",level:"6",type:"u",mandatory:"1",minver:"3",webm:"0"},e5:{name:"TrackPlaneUID",level:"6",type:"u",mandatory:"1",minver:"3",webm:"0",range:"not 0"},e4:{name:"TrackPlane",level:"5",type:"m",mandatory:"1",multiple:"1",minver:"3",webm:"0"},e3:{name:"TrackCombinePlanes",level:"4",type:"m",minver:"3",webm:"0"},e2:{name:"TrackOperation",level:"3",type:"m",minver:"3",webm:"0"},"7d7b":{name:"ChannelPositions",level:"4",type:"b",webm:"0"},"9f":{name:"Channels",level:"4",type:"u",mandatory:"1",minver:"1",default:"1",range:"not 0"},"78b5":{name:"OutputSamplingFrequency",level:"4",type:"f",minver:"1",default:"Sampling Frequency",range:"> 0"},b5:{name:"SamplingFrequency",level:"4",type:"f",mandatory:"1",minver:"1",default:"8000.0",range:"> 0"},e1:{name:"Audio",level:"3",type:"m",minver:"1"},"2383e3":{name:"FrameRate",level:"4",type:"f",range:"> 0",strong:"Informational"},"2fb523":{name:"GammaValue",level:"4",type:"f",webm:"0",range:"> 0"},"2eb524":{name:"ColourSpace",level:"4",type:"b",minver:"1",webm:"0",bytesize:"4"},"54b3":{name:"AspectRatioType",level:"4",type:"u",minver:"1",default:"0"},"54b2":{name:"DisplayUnit",level:"4",type:"u",minver:"1",default:"0"},"54ba":{name:"DisplayHeight",level:"4",type:"u",minver:"1",default:"PixelHeight",range:"not 0"},"54b0":{name:"DisplayWidth",level:"4",type:"u",minver:"1",default:"PixelWidth",range:"not 0"},"54dd":{name:"PixelCropRight",level:"4",type:"u",minver:"1",default:"0"},"54cc":{name:"PixelCropLeft",level:"4",type:"u",minver:"1",default:"0"},"54bb":{name:"PixelCropTop",level:"4",type:"u",minver:"1",default:"0"},"54aa":{name:"PixelCropBottom",level:"4",type:"u",minver:"1",default:"0"},ba:{name:"PixelHeight",level:"4",type:"u",mandatory:"1",minver:"1",range:"not 0"},b0:{name:"PixelWidth",level:"4",type:"u",mandatory:"1",minver:"1",range:"not 0"},"53b9":{name:"OldStereoMode",level:"4",type:"u",maxver:"0",webm:"0",divx:"0"},"53c0":{name:"AlphaMode",level:"4",type:"u",minver:"3",webm:"1",default:"0"},"53b8":{name:"StereoMode",level:"4",type:"u",minver:"3",webm:"1",default:"0"},"9a":{name:"FlagInterlaced",level:"4",type:"u",mandatory:"1",minver:"2",webm:"1",default:"0",range:"0-1"},e0:{name:"Video",level:"3",type:"m",minver:"1"},"66a5":{name:"TrackTranslateTrackID",level:"4",type:"b",mandatory:"1",minver:"1",webm:"0"},"66bf":{name:"TrackTranslateCodec",level:"4",type:"u",mandatory:"1",minver:"1",webm:"0"},"66fc":{name:"TrackTranslateEditionUID",level:"4",type:"u",multiple:"1",minver:"1",webm:"0"},"56bb":{name:"SeekPreRoll",level:"3",type:"u",mandatory:"1",multiple:"0",default:"0",minver:"4",webm:"1"},"56aa":{name:"CodecDelay",level:"3",type:"u",multiple:"0",default:"0",minver:"4",webm:"1"},"6fab":{name:"TrackOverlay",level:"3",type:"u",multiple:"1",minver:"1",webm:"0"},aa:{name:"CodecDecodeAll",level:"3",type:"u",mandatory:"1",minver:"2",webm:"0",default:"1",range:"0-1"},"26b240":{name:"CodecDownloadURL",level:"3",type:"s",multiple:"1",webm:"0"},"3b4040":{name:"CodecInfoURL",level:"3",type:"s",multiple:"1",webm:"0"},"3a9697":{name:"CodecSettings",level:"3",type:"8",webm:"0"},"63a2":{name:"CodecPrivate",level:"3",type:"b",minver:"1"},"22b59c":{name:"Language",level:"3",type:"s",minver:"1",default:"eng"},"536e":{name:"Name",level:"3",type:"8",minver:"1"},"55ee":{name:"MaxBlockAdditionID",level:"3",type:"u",mandatory:"1",minver:"1",webm:"0",default:"0"},"537f":{name:"TrackOffset",level:"3",type:"i",webm:"0",default:"0"},"23314f":{name:"TrackTimecodeScale",level:"3",type:"f",mandatory:"1",minver:"1",maxver:"3",webm:"0",default:"1.0",range:"> 0"},"234e7a":{name:"DefaultDecodedFieldDuration",level:"3",type:"u",minver:"4",range:"not 0"},"23e383":{name:"DefaultDuration",level:"3",type:"u",minver:"1",range:"not 0"},"6df8":{name:"MaxCache",level:"3",type:"u",minver:"1",webm:"0"},"6de7":{name:"MinCache",level:"3",type:"u",mandatory:"1",minver:"1",webm:"0",default:"0"},"9c":{name:"FlagLacing",level:"3",type:"u",mandatory:"1",minver:"1",default:"1",range:"0-1"},"55aa":{name:"FlagForced",level:"3",type:"u",mandatory:"1",minver:"1",default:"0",range:"0-1"},b9:{name:"FlagEnabled",level:"3",type:"u",mandatory:"1",minver:"2",webm:"1",default:"1",range:"0-1"},"73c5":{name:"TrackUID",level:"3",type:"u",mandatory:"1",minver:"1",range:"not 0"},d7:{name:"TrackNumber",level:"3",type:"u",mandatory:"1",minver:"1",range:"not 0"},ae:{name:"TrackEntry",level:"2",type:"m",mandatory:"1",multiple:"1",minver:"1"},"1654ae6b":{name:"Tracks",level:"1",type:"m",multiple:"1",minver:"1"},af:{name:"EncryptedBlock",level:"2",type:"b",multiple:"1",webm:"0"},ca:{name:"ReferenceTimeCode",level:"4",type:"u",multiple:"0",mandatory:"1",minver:"0",webm:"0",divx:"1"},c9:{name:"ReferenceOffset",level:"4",type:"u",multiple:"0",mandatory:"1",minver:"0",webm:"0",divx:"1"},c8:{name:"ReferenceFrame",level:"3",type:"m",multiple:"0",minver:"0",webm:"0",divx:"1"},cf:{name:"SliceDuration",level:"5",type:"u",default:"0"},ce:{name:"Delay",level:"5",type:"u",default:"0"},cb:{name:"BlockAdditionID",level:"5",type:"u",default:"0"},cd:{name:"FrameNumber",level:"5",type:"u",default:"0"},cc:{name:"LaceNumber",level:"5",type:"u",minver:"1",default:"0",divx:"0"},e8:{name:"TimeSlice",level:"4",type:"m",multiple:"1",minver:"1",divx:"0"},"8e":{name:"Slices",level:"3",type:"m",minver:"1",divx:"0"},"75a2":{name:"DiscardPadding",level:"3",type:"i",minver:"4",webm:"1"},a4:{name:"CodecState",level:"3",type:"b",minver:"2",webm:"0"},fd:{name:"ReferenceVirtual",level:"3",type:"i",webm:"0"},fb:{name:"ReferenceBlock",level:"3",type:"i",multiple:"1",minver:"1"},fa:{name:"ReferencePriority",level:"3",type:"u",mandatory:"1",minver:"1",webm:"0",default:"0"},"9b":{name:"BlockDuration",level:"3",type:"u",minver:"1",default:"TrackDuration"},a5:{name:"BlockAdditional",level:"5",type:"b",mandatory:"1",minver:"1",webm:"0"},ee:{name:"BlockAddID",level:"5",type:"u",mandatory:"1",minver:"1",webm:"0",default:"1",range:"not 0"},a6:{name:"BlockMore",level:"4",type:"m",mandatory:"1",multiple:"1",minver:"1",webm:"0"},"75a1":{name:"BlockAdditions",level:"3",type:"m",minver:"1",webm:"0"},a2:{name:"BlockVirtual",level:"3",type:"b",webm:"0"},a1:{name:"Block",level:"3",type:"b",mandatory:"1",minver:"1"},a0:{name:"BlockGroup",level:"2",type:"m",multiple:"1",minver:"1"},a3:{name:"SimpleBlock",level:"2",type:"b",multiple:"1",minver:"2",webm:"1",divx:"1"},ab:{name:"PrevSize",level:"2",type:"u",minver:"1"},a7:{name:"Position",level:"2",type:"u",minver:"1",webm:"0"},"58d7":{name:"SilentTrackNumber",level:"3",type:"u",multiple:"1",minver:"1",webm:"0"},e7:{name:"Timecode",level:"2",type:"u",mandatory:"1",minver:"1"},"1f43b675":{name:"Cluster",level:"1",type:"m",multiple:"1",minver:"1"},"4d80":{name:"MuxingApp",level:"2",type:"8",mandatory:"1",minver:"1"},"7ba9":{name:"Title",level:"2",type:"8",minver:"1",webm:"0"},"2ad7b2":{name:"TimecodeScaleDenominator",level:"2",type:"u",mandatory:"1",minver:"4",default:"1000000000"},"2ad7b1":{name:"TimecodeScale",level:"2",type:"u",mandatory:"1",minver:"1",default:"1000000"},"69a5":{name:"ChapterTranslateID",level:"3",type:"b",mandatory:"1",minver:"1",webm:"0"},"69bf":{name:"ChapterTranslateCodec",level:"3",type:"u",mandatory:"1",minver:"1",webm:"0"},"69fc":{name:"ChapterTranslateEditionUID",level:"3",type:"u",multiple:"1",minver:"1",webm:"0"},"3e83bb":{name:"NextFilename",level:"2",type:"8",minver:"1",webm:"0"},"3eb923":{name:"NextUID",level:"2",type:"b",minver:"1",webm:"0",bytesize:"16"},"3c83ab":{name:"PrevFilename",level:"2",type:"8",minver:"1",webm:"0"},"3cb923":{name:"PrevUID",level:"2",type:"b",minver:"1",webm:"0",bytesize:"16"},"73a4":{name:"SegmentUID",level:"2",type:"b",minver:"1",webm:"0",range:"not 0",bytesize:"16"},"1549a966":{name:"Info",level:"1",type:"m",mandatory:"1",multiple:"1",minver:"1"},"53ac":{name:"SeekPosition",level:"3",type:"u",mandatory:"1",minver:"1"},"53ab":{name:"SeekID",level:"3",type:"b",mandatory:"1",minver:"1"},"4dbb":{name:"Seek",level:"2",type:"m",mandatory:"1",multiple:"1",minver:"1"},"114d9b74":{name:"SeekHead",level:"1",type:"m",multiple:"1",minver:"1"},"7e7b":{name:"SignatureElementList",level:"2",type:"m",multiple:"1",webm:"0",i:"Cluster|Block|BlockAdditional"},"7e5b":{name:"SignatureElements",level:"1",type:"m",webm:"0"},"7eb5":{name:"Signature",level:"1",type:"b",webm:"0"},"7ea5":{name:"SignaturePublicKey",level:"1",type:"b",webm:"0"},"7e9a":{name:"SignatureHash",level:"1",type:"u",webm:"0"},"7e8a":{name:"SignatureAlgo",level:"1",type:"u",webm:"0"},"1b538667":{name:"SignatureSlot",level:"-1",type:"m",multiple:"1",webm:"0"},bf:{name:"CRC-32",level:"-1",type:"b",minver:"1",webm:"0"},ec:{name:"Void",level:"-1",type:"b",minver:"1"},"42f3":{name:"EBMLMaxSizeLength",level:"1",type:"u",mandatory:"1",default:"8",minver:"1"},"42f2":{name:"EBMLMaxIDLength",level:"1",type:"u",mandatory:"1",default:"4",minver:"1"},"42f7":{name:"EBMLReadVersion",level:"1",type:"u",mandatory:"1",default:"1",minver:"1"},"1a45dfa3":{name:"EBML",level:"0",type:"m",mandatory:"1",multiple:"1",minver:"1"}};module.exports=schema;
},{}],11:[function(require,module,exports){
var Buffer = require("buffer").Buffer, tools = {
  readVint: function(r, e) {
    e = e || 0;
    for (var t = 1; t <= 8; t++) if (r[e] >= Math.pow(2, 8 - t)) break;
    if (t > 8) throw new Error("Unrepresentable length: " + t + " " + r.toString("hex", e, e + t));
    if (e + t > r.length) return null;
    for (var n = r[e] & (1 << 8 - t) - 1, o = 1; o < t; o++) {
      if (7 === o && n >= Math.pow(2, 45) && r[e + 7] > 0) return {
        length: t,
        value: -1
      };
      n *= Math.pow(2, 8);
      n += r[e + o];
    }
    return {
      length: t,
      value: n
    };
  },
  writeVint: function(r) {
    if (r < 0 || r > Math.pow(2, 53)) throw new Error("Unrepresentable value: " + r);
    for (var e = 1; e <= 8; e++) if (r < Math.pow(2, 7 * e) - 1) break;
    for (var t = new Buffer(e), n = 1; n <= e; n++) {
      r -= t[e - n] = 255 & r;
      r /= Math.pow(2, 8);
    }
    t[0] = t[0] | 1 << 8 - e;
    return t;
  }
};

module.exports = tools;
},{"buffer":8}],12:[function(require,module,exports){
var once = require("once"), noop = function() {}, eos = function(r, e, n) {
  if ("function" === typeof e) return eos(r, null, e);
  e || (e = {});
  n = once(n || noop);
  var o = r._writableState, t = r._readableState, i = e.readable || !1 !== e.readable && r.readable, l = e.writable || !1 !== e.writable && r.writable, c = function() {
    r.writable || s();
  }, s = function() {
    l = !1;
    i || n.call(r);
  }, a = function() {
    i = !1;
    l || n.call(r);
  }, u = function(e) {
    n.call(r, e ? new Error("exited with error code: " + e) : null);
  }, f = function(e) {
    n.call(r, e);
  }, d = function() {
    return (!i || t && t.ended) && (!l || o && o.ended) ? void 0 : n.call(r, new Error("premature close"));
  }, m = function() {
    r.req.on("finish", s);
  };
  if (l && !o) {
    r.on("end", c);
    r.on("close", c);
  }
  r.on("end", a);
  r.on("finish", s);
  !1 !== e.error && r.on("error", f);
  r.on("close", d);
  return function() {
    r.removeListener("complete", s);
    r.removeListener("abort", d);
    r.removeListener("request", m);
    r.req && r.req.removeListener("finish", s);
    r.removeListener("end", c);
    r.removeListener("close", c);
    r.removeListener("finish", s);
    r.removeListener("exit", u);
    r.removeListener("end", a);
    r.removeListener("error", f);
    r.removeListener("close", d);
  };
};

module.exports = eos;
},{"once":23}],13:[function(require,module,exports){
"use strict";

var has = Object.prototype.hasOwnProperty, prefix = "~";

function Events() {}

if (Object.create) {
  Events.prototype = Object.create(null);
  new Events().__proto__ || (prefix = !1);
}

function EE(e, t, n) {
  this.fn = e;
  this.context = t;
  this.once = n || !1;
}

function addListener(e, t, n, r, i, s) {
  if ("function" !== typeof n) throw new TypeError("The listener must be a function");
  var o = new EE(n, r || e, i), f = prefix ? prefix + t : t;
  e._events[f] ? e._events[f].fn ? e._events[f] = s ? [ o, e._events[f] ] : [ e._events[f], o ] : e._events[f][s ? "unshift" : "push"](o) : (e._events[f] = o, 
  e._eventsCount++);
  return e;
}

function clearEvent(e, t) {
  0 === --e._eventsCount ? e._events = new Events() : delete e._events[t];
}

function EventEmitter() {
  this._events = new Events();
  this._eventsCount = 0;
}

EventEmitter.prototype.eventNames = function() {
  var e, t, n = [];
  if (0 === this._eventsCount) return n;
  for (t in e = this._events) has.call(e, t) && n.push(prefix ? t.slice(1) : t);
  return Object.getOwnPropertySymbols ? n.concat(Object.getOwnPropertySymbols(e)) : n;
};

EventEmitter.prototype.listeners = function(e) {
  var t = this._events[prefix ? prefix + e : e];
  if (!t) return [];
  if (t.fn) return [ t.fn ];
  for (var n = 0, r = t.length, i = new Array(r); n < r; n++) i[n] = t[n].fn;
  return i;
};

EventEmitter.prototype.listenerCount = function(e) {
  var t = this._events[prefix ? prefix + e : e];
  return t ? t.fn ? 1 : t.length : 0;
};

EventEmitter.prototype.emit = function(e, t, n, r, i, s) {
  var o = prefix ? prefix + e : e;
  if (!this._events[o]) return !1;
  var f, c, v = this._events[o], a = arguments.length;
  if (v.fn) {
    v.once && this.removeListener(e, v.fn, void 0, !0);
    switch (a) {
     case 1:
      return v.fn.call(v.context), !0;

     case 2:
      return v.fn.call(v.context, t), !0;

     case 3:
      return v.fn.call(v.context, t, n), !0;

     case 4:
      return v.fn.call(v.context, t, n, r), !0;

     case 5:
      return v.fn.call(v.context, t, n, r, i), !0;

     case 6:
      return v.fn.call(v.context, t, n, r, i, s), !0;
    }
    for (c = 1, f = new Array(a - 1); c < a; c++) f[c - 1] = arguments[c];
    v.fn.apply(v.context, f);
  } else {
    var p, l = v.length;
    for (c = 0; c < l; c++) {
      v[c].once && this.removeListener(e, v[c].fn, void 0, !0);
      switch (a) {
       case 1:
        v[c].fn.call(v[c].context);
        break;

       case 2:
        v[c].fn.call(v[c].context, t);
        break;

       case 3:
        v[c].fn.call(v[c].context, t, n);
        break;

       case 4:
        v[c].fn.call(v[c].context, t, n, r);
        break;

       default:
        if (!f) for (p = 1, f = new Array(a - 1); p < a; p++) f[p - 1] = arguments[p];
        v[c].fn.apply(v[c].context, f);
      }
    }
  }
  return !0;
};

EventEmitter.prototype.on = function(e, t, n, r) {
  return addListener(this, e, t, n, !1, r);
};

EventEmitter.prototype.once = function(e, t, n) {
  return addListener(this, e, t, n, !0);
};

EventEmitter.prototype.removeListener = function(e, t, n, r) {
  var i = prefix ? prefix + e : e;
  if (!this._events[i]) return this;
  if (!t) {
    clearEvent(this, i);
    return this;
  }
  var s = this._events[i];
  if (s.fn) s.fn !== t || r && !s.once || n && s.context !== n || clearEvent(this, i); else {
    for (var o = 0, f = [], c = s.length; o < c; o++) (s[o].fn !== t || r && !s[o].once || n && s[o].context !== n) && f.push(s[o]);
    f.length ? this._events[i] = 1 === f.length ? f[0] : f : clearEvent(this, i);
  }
  return this;
};

EventEmitter.prototype.removeAllListeners = function(e) {
  var t;
  if (e) this._events[t = prefix ? prefix + e : e] && clearEvent(this, t); else {
    this._events = new Events();
    this._eventsCount = 0;
  }
  return this;
};

EventEmitter.prototype.off = EventEmitter.prototype.removeListener;

EventEmitter.prototype.addListener = EventEmitter.prototype.on;

EventEmitter.prefixed = prefix;

EventEmitter.EventEmitter = EventEmitter;

"undefined" !== typeof module && (module.exports = EventEmitter);
},{}],14:[function(require,module,exports){
exports.read = function(t, a, o, f, i) {
  var r, e, h = 8 * i - f - 1, M = (1 << h) - 1, p = M >> 1, n = -7, w = o ? i - 1 : 0, s = o ? -1 : 1, N = t[a + w];
  w += s;
  r = N & (1 << -n) - 1;
  N >>= -n;
  n += h;
  for (;n > 0; r = 256 * r + t[a + w], w += s, n -= 8) ;
  e = r & (1 << -n) - 1;
  r >>= -n;
  n += f;
  for (;n > 0; e = 256 * e + t[a + w], w += s, n -= 8) ;
  if (0 === r) r = 1 - p; else {
    if (r === M) return e ? NaN : Infinity * (N ? -1 : 1);
    e += Math.pow(2, f);
    r -= p;
  }
  return (N ? -1 : 1) * e * Math.pow(2, r - f);
};

exports.write = function(t, a, o, f, i, r) {
  var e, h, M, p = 8 * r - i - 1, n = (1 << p) - 1, w = n >> 1, s = 23 === i ? Math.pow(2, -24) - Math.pow(2, -77) : 0, N = f ? 0 : r - 1, l = f ? 1 : -1, u = a < 0 || 0 === a && 1 / a < 0 ? 1 : 0;
  a = Math.abs(a);
  if (isNaN(a) || Infinity === a) {
    h = isNaN(a) ? 1 : 0;
    e = n;
  } else {
    e = Math.floor(Math.log(a) / Math.LN2);
    if (a * (M = Math.pow(2, -e)) < 1) {
      e--;
      M *= 2;
    }
    if ((a += e + w >= 1 ? s / M : s * Math.pow(2, 1 - w)) * M >= 2) {
      e++;
      M /= 2;
    }
    if (e + w >= n) {
      h = 0;
      e = n;
    } else if (e + w >= 1) {
      h = (a * M - 1) * Math.pow(2, i);
      e += w;
    } else {
      h = a * Math.pow(2, w - 1) * Math.pow(2, i);
      e = 0;
    }
  }
  for (;i >= 8; t[o + N] = 255 & h, N += l, h /= 256, i -= 8) ;
  e = e << i | h;
  p += i;
  for (;p > 0; t[o + N] = 255 & e, N += l, e /= 256, p -= 8) ;
  t[o + N - l] |= 128 * u;
};
},{}],15:[function(require,module,exports){
module.exports = MediaElementWrapper;

var inherits = require("/bundle/utils").inherit, stream = require("readable-stream"), toArrayBuffer = require("to-arraybuffer"), MediaSource = "undefined" !== typeof window && window.MediaSource, DEFAULT_BUFFER_DURATION = 60;

function MediaElementWrapper(e, r) {
  var t = this;
  if (!(t instanceof MediaElementWrapper)) return new MediaElementWrapper(e, r);
  if (!MediaSource) throw new Error("web browser lacks MediaSource support");
  r || (r = {});
  t._debug = r.debug;
  t._bufferDuration = r.bufferDuration || DEFAULT_BUFFER_DURATION;
  t._elem = e;
  t._mediaSource = new MediaSource();
  t._streams = [];
  t.detailedError = null;
  t._errorHandler = function() {
    t._elem.removeEventListener("error", t._errorHandler);
    t._streams.slice().forEach(function(e) {
      e.destroy(t._elem.error);
    });
  };
  t._elem.addEventListener("error", t._errorHandler);
  t._elem.src = window.URL.createObjectURL(t._mediaSource);
}

MediaElementWrapper.prototype.createWriteStream = function(e) {
  return new MediaSourceStream(this, e);
};

MediaElementWrapper.prototype.error = function(e) {
  var r = this;
  r.detailedError || (r.detailedError = e);
  r._dumpDebugData();
  try {
    r._mediaSource.endOfStream("decode");
  } catch (e) {}
};

MediaElementWrapper.prototype._dumpDebugData = function() {
  var e = this;
  if (e._debug) {
    e._debug = !1;
    e._streams.forEach(function(e, r) {
      downloadBuffers(e._debugBuffers, "mediasource-stream-" + r);
    });
  }
};

inherits(MediaSourceStream, stream.Writable);

function MediaSourceStream(e, r) {
  var t = this;
  stream.Writable.call(t);
  t._wrapper = e;
  t._elem = e._elem;
  t._mediaSource = e._mediaSource;
  t._allStreams = e._streams;
  t._allStreams.push(t);
  t._bufferDuration = e._bufferDuration;
  t._sourceBuffer = null;
  t._debugBuffers = [];
  t._openHandler = function() {
    t._onSourceOpen();
  };
  t._flowHandler = function() {
    t._flow();
  };
  t._errorHandler = function(e) {
    t.destroyed || t.emit("error", e);
  };
  if ("string" === typeof r) {
    t._type = r;
    "open" === t._mediaSource.readyState ? t._createSourceBuffer() : t._mediaSource.addEventListener("sourceopen", t._openHandler);
  } else if (null === r._sourceBuffer) {
    r.destroy();
    t._type = r._type;
    t._mediaSource.addEventListener("sourceopen", t._openHandler);
  } else {
    if (!r._sourceBuffer) throw new Error("The argument to MediaElementWrapper.createWriteStream must be a string or a previous stream returned from that function");
    r.destroy();
    t._type = r._type;
    t._sourceBuffer = r._sourceBuffer;
    t._debugBuffers = r._debugBuffers;
    t._sourceBuffer.addEventListener("updateend", t._flowHandler);
    t._sourceBuffer.addEventListener("error", t._errorHandler);
  }
  t._elem.addEventListener("timeupdate", t._flowHandler);
  t.on("error", function(e) {
    t._wrapper.error(e);
  });
  t.on("finish", function() {
    if (!t.destroyed) {
      t._finished = !0;
      if (t._allStreams.every(function(e) {
        return e._finished;
      })) {
        t._wrapper._dumpDebugData();
        try {
          t._mediaSource.endOfStream();
        } catch (e) {}
      }
    }
  });
}

MediaSourceStream.prototype._onSourceOpen = function() {
  var e = this;
  if (!e.destroyed) {
    e._mediaSource.removeEventListener("sourceopen", e._openHandler);
    e._createSourceBuffer();
  }
};

MediaSourceStream.prototype.destroy = function(e) {
  var r = this;
  if (!r.destroyed) {
    r.destroyed = !0;
    r._allStreams.splice(r._allStreams.indexOf(r), 1);
    r._mediaSource.removeEventListener("sourceopen", r._openHandler);
    r._elem.removeEventListener("timeupdate", r._flowHandler);
    if (r._sourceBuffer) {
      r._sourceBuffer.removeEventListener("updateend", r._flowHandler);
      r._sourceBuffer.removeEventListener("error", r._errorHandler);
      "open" === r._mediaSource.readyState && r._sourceBuffer.abort();
    }
    e && r.emit("error", e);
    r.emit("close");
  }
};

MediaSourceStream.prototype._createSourceBuffer = function() {
  var e = this;
  if (!e.destroyed) if (MediaSource.isTypeSupported(e._type)) {
    e._sourceBuffer = e._mediaSource.addSourceBuffer(e._type);
    e._sourceBuffer.addEventListener("updateend", e._flowHandler);
    e._sourceBuffer.addEventListener("error", e._errorHandler);
    if (e._cb) {
      var r = e._cb;
      e._cb = null;
      r();
    }
  } else onIdle(e.destroy.bind(e, new Error("The provided type is not supported")));
};

MediaSourceStream.prototype._write = function(r, t, o) {
  var a = this;
  if (!a.destroyed) if (a._sourceBuffer) {
    if (a._sourceBuffer.updating) return o(new Error("Cannot append buffer while source buffer updating"));
    var e = toArrayBuffer(r);
    a._wrapper._debug && a._debugBuffers.push(e);
    try {
      a._sourceBuffer.appendBuffer(e);
    } catch (e) {
      a.destroy(e);
      return;
    }
    a._cb = o;
  } else a._cb = function(e) {
    if (e) return o(e);
    a._write(r, t, o);
  };
};

MediaSourceStream.prototype._flow = function() {
  var e = this;
  if (!e.destroyed && e._sourceBuffer && !e._sourceBuffer.updating && !("open" === e._mediaSource.readyState && e._getBufferDuration() > e._bufferDuration) && e._cb) {
    var r = e._cb;
    e._cb = null;
    r();
  }
};

var EPSILON = 0;

MediaSourceStream.prototype._getBufferDuration = function() {
  for (var e = this._sourceBuffer.buffered, r = this._elem.currentTime, t = -1, o = 0; o < e.length; o++) {
    var a = e.start(o), u = e.end(o) + EPSILON;
    if (a > r) break;
    (t >= 0 || r <= u) && (t = u);
  }
  var n = t - r;
  n < 0 && (n = 0);
  return n;
};

function downloadBuffers(e, r) {
  var t = document.createElement("a");
  t.href = window.URL.createObjectURL(new window.Blob(e));
  t.download = r;
  t.click();
}
},{"/bundle/utils":3,"readable-stream":35,"to-arraybuffer":36}],16:[function(require,module,exports){
var Buffer = require("buffer").Buffer, Box = require("./index"), Descriptor = require("./descriptor"), TIME_OFFSET = 20828448e5;

exports.fullBoxes = {};

var fullBoxes = [ "mvhd", "tkhd", "mdhd", "vmhd", "smhd", "stsd", "esds", "stsz", "stco", "stss", "stts", "ctts", "stsc", "dref", "elst", "hdlr", "mehd", "trex", "mfhd", "tfhd", "tfdt", "trun" ];

fullBoxes.forEach(function(e) {
  exports.fullBoxes[e] = !0;
});

exports.ftyp = {};

exports.ftyp.encode = function(e, t, r) {
  t = t ? t.slice(r) : Buffer.allocUnsafe(exports.ftyp.encodingLength(e));
  var n = e.compatibleBrands || [];
  t.write(e.brand, 0, 4, "ascii");
  t.writeUInt32BE(e.brandVersion, 4);
  for (var o = 0; o < n.length; o++) t.write(n[o], 8 + 4 * o, 4, "ascii");
  exports.ftyp.encode.bytes = 8 + 4 * n.length;
  return t;
};

exports.ftyp.decode = function(e, t) {
  for (var r = (e = e.slice(t)).toString("ascii", 0, 4), n = e.readUInt32BE(4), o = [], i = 8; i < e.length; i += 4) o.push(e.toString("ascii", i, i + 4));
  return {
    brand: r,
    brandVersion: n,
    compatibleBrands: o
  };
};

exports.ftyp.encodingLength = function(e) {
  return 8 + 4 * (e.compatibleBrands || []).length;
};

exports.mvhd = {};

exports.mvhd.encode = function(e, t, r) {
  t = t ? t.slice(r) : Buffer.allocUnsafe(96);
  writeDate(e.ctime || new Date(), t, 0);
  writeDate(e.mtime || new Date(), t, 4);
  t.writeUInt32BE(e.timeScale || 0, 8);
  t.writeUInt32BE(e.duration || 0, 12);
  writeFixed32(e.preferredRate || 0, t, 16);
  writeFixed16(e.preferredVolume || 0, t, 20);
  writeReserved(t, 22, 32);
  writeMatrix(e.matrix, t, 32);
  t.writeUInt32BE(e.previewTime || 0, 68);
  t.writeUInt32BE(e.previewDuration || 0, 72);
  t.writeUInt32BE(e.posterTime || 0, 76);
  t.writeUInt32BE(e.selectionTime || 0, 80);
  t.writeUInt32BE(e.selectionDuration || 0, 84);
  t.writeUInt32BE(e.currentTime || 0, 88);
  t.writeUInt32BE(e.nextTrackId || 0, 92);
  exports.mvhd.encode.bytes = 96;
  return t;
};

exports.mvhd.decode = function(e, t) {
  return {
    ctime: readDate(e = e.slice(t), 0),
    mtime: readDate(e, 4),
    timeScale: e.readUInt32BE(8),
    duration: e.readUInt32BE(12),
    preferredRate: readFixed32(e, 16),
    preferredVolume: readFixed16(e, 20),
    matrix: readMatrix(e.slice(32, 68)),
    previewTime: e.readUInt32BE(68),
    previewDuration: e.readUInt32BE(72),
    posterTime: e.readUInt32BE(76),
    selectionTime: e.readUInt32BE(80),
    selectionDuration: e.readUInt32BE(84),
    currentTime: e.readUInt32BE(88),
    nextTrackId: e.readUInt32BE(92)
  };
};

exports.mvhd.encodingLength = function(e) {
  return 96;
};

exports.tkhd = {};

exports.tkhd.encode = function(e, t, r) {
  t = t ? t.slice(r) : Buffer.allocUnsafe(80);
  writeDate(e.ctime || new Date(), t, 0);
  writeDate(e.mtime || new Date(), t, 4);
  t.writeUInt32BE(e.trackId || 0, 8);
  writeReserved(t, 12, 16);
  t.writeUInt32BE(e.duration || 0, 16);
  writeReserved(t, 20, 28);
  t.writeUInt16BE(e.layer || 0, 28);
  t.writeUInt16BE(e.alternateGroup || 0, 30);
  t.writeUInt16BE(e.volume || 0, 32);
  writeMatrix(e.matrix, t, 36);
  t.writeUInt32BE(e.trackWidth || 0, 72);
  t.writeUInt32BE(e.trackHeight || 0, 76);
  exports.tkhd.encode.bytes = 80;
  return t;
};

exports.tkhd.decode = function(e, t) {
  return {
    ctime: readDate(e = e.slice(t), 0),
    mtime: readDate(e, 4),
    trackId: e.readUInt32BE(8),
    duration: e.readUInt32BE(16),
    layer: e.readUInt16BE(28),
    alternateGroup: e.readUInt16BE(30),
    volume: e.readUInt16BE(32),
    matrix: readMatrix(e.slice(36, 72)),
    trackWidth: e.readUInt32BE(72),
    trackHeight: e.readUInt32BE(76)
  };
};

exports.tkhd.encodingLength = function(e) {
  return 80;
};

exports.mdhd = {};

exports.mdhd.encode = function(e, t, r) {
  t = t ? t.slice(r) : Buffer.allocUnsafe(20);
  writeDate(e.ctime || new Date(), t, 0);
  writeDate(e.mtime || new Date(), t, 4);
  t.writeUInt32BE(e.timeScale || 0, 8);
  t.writeUInt32BE(e.duration || 0, 12);
  t.writeUInt16BE(e.language || 0, 16);
  t.writeUInt16BE(e.quality || 0, 18);
  exports.mdhd.encode.bytes = 20;
  return t;
};

exports.mdhd.decode = function(e, t) {
  return {
    ctime: readDate(e = e.slice(t), 0),
    mtime: readDate(e, 4),
    timeScale: e.readUInt32BE(8),
    duration: e.readUInt32BE(12),
    language: e.readUInt16BE(16),
    quality: e.readUInt16BE(18)
  };
};

exports.mdhd.encodingLength = function(e) {
  return 20;
};

exports.vmhd = {};

exports.vmhd.encode = function(e, t, r) {
  (t = t ? t.slice(r) : Buffer.allocUnsafe(8)).writeUInt16BE(e.graphicsMode || 0, 0);
  var n = e.opcolor || [ 0, 0, 0 ];
  t.writeUInt16BE(n[0], 2);
  t.writeUInt16BE(n[1], 4);
  t.writeUInt16BE(n[2], 6);
  exports.vmhd.encode.bytes = 8;
  return t;
};

exports.vmhd.decode = function(e, t) {
  return {
    graphicsMode: (e = e.slice(t)).readUInt16BE(0),
    opcolor: [ e.readUInt16BE(2), e.readUInt16BE(4), e.readUInt16BE(6) ]
  };
};

exports.vmhd.encodingLength = function(e) {
  return 8;
};

exports.smhd = {};

exports.smhd.encode = function(e, t, r) {
  (t = t ? t.slice(r) : Buffer.allocUnsafe(4)).writeUInt16BE(e.balance || 0, 0);
  writeReserved(t, 2, 4);
  exports.smhd.encode.bytes = 4;
  return t;
};

exports.smhd.decode = function(e, t) {
  return {
    balance: (e = e.slice(t)).readUInt16BE(0)
  };
};

exports.smhd.encodingLength = function(e) {
  return 4;
};

exports.stsd = {};

exports.stsd.encode = function(e, t, r) {
  t = t ? t.slice(r) : Buffer.allocUnsafe(exports.stsd.encodingLength(e));
  var n = e.entries || [];
  t.writeUInt32BE(n.length, 0);
  for (var o = 4, i = 0; i < n.length; i++) {
    Box.encode(n[i], t, o);
    o += Box.encode.bytes;
  }
  exports.stsd.encode.bytes = o;
  return t;
};

exports.stsd.decode = function(e, t, r) {
  for (var n = (e = e.slice(t)).readUInt32BE(0), o = new Array(n), i = 4, s = 0; s < n; s++) {
    var d = Box.decode(e, i, r);
    i += (o[s] = d).length;
  }
  return {
    entries: o
  };
};

exports.stsd.encodingLength = function(e) {
  var t = 4;
  if (!e.entries) return t;
  for (var r = 0; r < e.entries.length; r++) t += Box.encodingLength(e.entries[r]);
  return t;
};

exports.avc1 = exports.VisualSampleEntry = {};

exports.VisualSampleEntry.encode = function(e, t, r) {
  writeReserved(t = t ? t.slice(r) : Buffer.allocUnsafe(exports.VisualSampleEntry.encodingLength(e)), 0, 6);
  t.writeUInt16BE(e.dataReferenceIndex || 0, 6);
  writeReserved(t, 8, 24);
  t.writeUInt16BE(e.width || 0, 24);
  t.writeUInt16BE(e.height || 0, 26);
  t.writeUInt32BE(e.hResolution || 4718592, 28);
  t.writeUInt32BE(e.vResolution || 4718592, 32);
  writeReserved(t, 36, 40);
  t.writeUInt16BE(e.frameCount || 1, 40);
  var n = e.compressorName || "", o = Math.min(n.length, 31);
  t.writeUInt8(o, 42);
  t.write(n, 43, o, "utf8");
  t.writeUInt16BE(e.depth || 24, 74);
  t.writeInt16BE(-1, 76);
  var i = 78;
  (e.children || []).forEach(function(e) {
    Box.encode(e, t, i);
    i += Box.encode.bytes;
  });
  exports.VisualSampleEntry.encode.bytes = i;
};

exports.VisualSampleEntry.decode = function(e, t, r) {
  e = e.slice(t);
  var n = r - t, o = Math.min(e.readUInt8(42), 31), i = {
    dataReferenceIndex: e.readUInt16BE(6),
    width: e.readUInt16BE(24),
    height: e.readUInt16BE(26),
    hResolution: e.readUInt32BE(28),
    vResolution: e.readUInt32BE(32),
    frameCount: e.readUInt16BE(40),
    compressorName: e.toString("utf8", 43, 43 + o),
    depth: e.readUInt16BE(74),
    children: []
  }, s = 78;
  while (n - s >= 8) {
    var d = Box.decode(e, s, n);
    i.children.push(d);
    s += (i[d.type] = d).length;
  }
  return i;
};

exports.VisualSampleEntry.encodingLength = function(e) {
  var t = 78;
  (e.children || []).forEach(function(e) {
    t += Box.encodingLength(e);
  });
  return t;
};

exports.avcC = {};

exports.avcC.encode = function(e, t, r) {
  t = t ? t.slice(r) : Buffer.allocUnsafe(e.buffer.length);
  e.buffer.copy(t);
  exports.avcC.encode.bytes = e.buffer.length;
};

exports.avcC.decode = function(e, t, r) {
  return {
    mimeCodec: (e = e.slice(t, r)).toString("hex", 1, 4),
    buffer: Buffer.from(e)
  };
};

exports.avcC.encodingLength = function(e) {
  return e.buffer.length;
};

exports.mp4a = exports.AudioSampleEntry = {};

exports.AudioSampleEntry.encode = function(e, t, r) {
  writeReserved(t = t ? t.slice(r) : Buffer.allocUnsafe(exports.AudioSampleEntry.encodingLength(e)), 0, 6);
  t.writeUInt16BE(e.dataReferenceIndex || 0, 6);
  writeReserved(t, 8, 16);
  t.writeUInt16BE(e.channelCount || 2, 16);
  t.writeUInt16BE(e.sampleSize || 16, 18);
  writeReserved(t, 20, 24);
  t.writeUInt32BE(e.sampleRate || 0, 24);
  var n = 28;
  (e.children || []).forEach(function(e) {
    Box.encode(e, t, n);
    n += Box.encode.bytes;
  });
  exports.AudioSampleEntry.encode.bytes = n;
};

exports.AudioSampleEntry.decode = function(e, t, r) {
  var n = r - t, o = {
    dataReferenceIndex: (e = e.slice(t, r)).readUInt16BE(6),
    channelCount: e.readUInt16BE(16),
    sampleSize: e.readUInt16BE(18),
    sampleRate: e.readUInt32BE(24),
    children: []
  }, i = 28;
  while (n - i >= 8) {
    var s = Box.decode(e, i, n);
    o.children.push(s);
    i += (o[s.type] = s).length;
  }
  return o;
};

exports.AudioSampleEntry.encodingLength = function(e) {
  var t = 28;
  (e.children || []).forEach(function(e) {
    t += Box.encodingLength(e);
  });
  return t;
};

exports.esds = {};

exports.esds.encode = function(e, t, r) {
  t = t ? t.slice(r) : Buffer.allocUnsafe(e.buffer.length);
  e.buffer.copy(t, 0);
  exports.esds.encode.bytes = e.buffer.length;
};

exports.esds.decode = function(e, t, r) {
  e = e.slice(t, r);
  var n = Descriptor.Descriptor.decode(e, 0, e.length), o = ("ESDescriptor" === n.tagName ? n : {}).DecoderConfigDescriptor || {}, i = o.oti || 0, s = o.DecoderSpecificInfo, d = s ? (248 & s.buffer.readUInt8(0)) >> 3 : 0, a = null;
  if (i) {
    a = i.toString(16);
    d && (a += "." + d);
  }
  return {
    mimeCodec: a,
    buffer: Buffer.from(e.slice(0))
  };
};

exports.esds.encodingLength = function(e) {
  return e.buffer.length;
};

exports.stsz = {};

exports.stsz.encode = function(e, t, r) {
  var n = e.entries || [];
  (t = t ? t.slice(r) : Buffer.allocUnsafe(exports.stsz.encodingLength(e))).writeUInt32BE(0, 0);
  t.writeUInt32BE(n.length, 4);
  for (var o = 0; o < n.length; o++) t.writeUInt32BE(n[o], 4 * o + 8);
  exports.stsz.encode.bytes = 8 + 4 * n.length;
  return t;
};

exports.stsz.decode = function(e, t) {
  for (var r = (e = e.slice(t)).readUInt32BE(0), n = e.readUInt32BE(4), o = new Array(n), i = 0; i < n; i++) o[i] = 0 === r ? e.readUInt32BE(4 * i + 8) : r;
  return {
    entries: o
  };
};

exports.stsz.encodingLength = function(e) {
  return 8 + 4 * e.entries.length;
};

exports.stss = exports.stco = {};

exports.stco.encode = function(e, t, r) {
  var n = e.entries || [];
  (t = t ? t.slice(r) : Buffer.allocUnsafe(exports.stco.encodingLength(e))).writeUInt32BE(n.length, 0);
  for (var o = 0; o < n.length; o++) t.writeUInt32BE(n[o], 4 * o + 4);
  exports.stco.encode.bytes = 4 + 4 * n.length;
  return t;
};

exports.stco.decode = function(e, t) {
  for (var r = (e = e.slice(t)).readUInt32BE(0), n = new Array(r), o = 0; o < r; o++) n[o] = e.readUInt32BE(4 * o + 4);
  return {
    entries: n
  };
};

exports.stco.encodingLength = function(e) {
  return 4 + 4 * e.entries.length;
};

exports.stts = {};

exports.stts.encode = function(e, t, r) {
  var n = e.entries || [];
  (t = t ? t.slice(r) : Buffer.allocUnsafe(exports.stts.encodingLength(e))).writeUInt32BE(n.length, 0);
  for (var o = 0; o < n.length; o++) {
    var i = 8 * o + 4;
    t.writeUInt32BE(n[o].count || 0, i);
    t.writeUInt32BE(n[o].duration || 0, i + 4);
  }
  exports.stts.encode.bytes = 4 + 8 * e.entries.length;
  return t;
};

exports.stts.decode = function(e, t) {
  for (var r = (e = e.slice(t)).readUInt32BE(0), n = new Array(r), o = 0; o < r; o++) {
    var i = 8 * o + 4;
    n[o] = {
      count: e.readUInt32BE(i),
      duration: e.readUInt32BE(i + 4)
    };
  }
  return {
    entries: n
  };
};

exports.stts.encodingLength = function(e) {
  return 4 + 8 * e.entries.length;
};

exports.ctts = {};

exports.ctts.encode = function(e, t, r) {
  var n = e.entries || [];
  (t = t ? t.slice(r) : Buffer.allocUnsafe(exports.ctts.encodingLength(e))).writeUInt32BE(n.length, 0);
  for (var o = 0; o < n.length; o++) {
    var i = 8 * o + 4;
    t.writeUInt32BE(n[o].count || 0, i);
    t.writeUInt32BE(n[o].compositionOffset || 0, i + 4);
  }
  exports.ctts.encode.bytes = 4 + 8 * n.length;
  return t;
};

exports.ctts.decode = function(e, t) {
  for (var r = (e = e.slice(t)).readUInt32BE(0), n = new Array(r), o = 0; o < r; o++) {
    var i = 8 * o + 4;
    n[o] = {
      count: e.readUInt32BE(i),
      compositionOffset: e.readInt32BE(i + 4)
    };
  }
  return {
    entries: n
  };
};

exports.ctts.encodingLength = function(e) {
  return 4 + 8 * e.entries.length;
};

exports.stsc = {};

exports.stsc.encode = function(e, t, r) {
  var n = e.entries || [];
  (t = t ? t.slice(r) : Buffer.allocUnsafe(exports.stsc.encodingLength(e))).writeUInt32BE(n.length, 0);
  for (var o = 0; o < n.length; o++) {
    var i = 12 * o + 4;
    t.writeUInt32BE(n[o].firstChunk || 0, i);
    t.writeUInt32BE(n[o].samplesPerChunk || 0, i + 4);
    t.writeUInt32BE(n[o].sampleDescriptionId || 0, i + 8);
  }
  exports.stsc.encode.bytes = 4 + 12 * n.length;
  return t;
};

exports.stsc.decode = function(e, t) {
  for (var r = (e = e.slice(t)).readUInt32BE(0), n = new Array(r), o = 0; o < r; o++) {
    var i = 12 * o + 4;
    n[o] = {
      firstChunk: e.readUInt32BE(i),
      samplesPerChunk: e.readUInt32BE(i + 4),
      sampleDescriptionId: e.readUInt32BE(i + 8)
    };
  }
  return {
    entries: n
  };
};

exports.stsc.encodingLength = function(e) {
  return 4 + 12 * e.entries.length;
};

exports.dref = {};

exports.dref.encode = function(e, t, r) {
  t = t ? t.slice(r) : Buffer.allocUnsafe(exports.dref.encodingLength(e));
  var n = e.entries || [];
  t.writeUInt32BE(n.length, 0);
  for (var o = 4, i = 0; i < n.length; i++) {
    var s = n[i];
    t.writeUInt32BE((s.buf ? s.buf.length : 0) + 4 + 4, o);
    t.write(s.type, o += 4, 4, "ascii");
    o += 4;
    if (s.buf) {
      s.buf.copy(t, o);
      o += s.buf.length;
    }
  }
  exports.dref.encode.bytes = o;
  return t;
};

exports.dref.decode = function(e, t) {
  for (var r = (e = e.slice(t)).readUInt32BE(0), n = new Array(r), o = 4, i = 0; i < r; i++) {
    var s = e.readUInt32BE(o), d = e.toString("ascii", o + 4, o + 8), a = e.slice(o + 8, o + s);
    o += s;
    n[i] = {
      type: d,
      buf: a
    };
  }
  return {
    entries: n
  };
};

exports.dref.encodingLength = function(e) {
  var t = 4;
  if (!e.entries) return t;
  for (var r = 0; r < e.entries.length; r++) {
    var n = e.entries[r].buf;
    t += (n ? n.length : 0) + 4 + 4;
  }
  return t;
};

exports.elst = {};

exports.elst.encode = function(e, t, r) {
  var n = e.entries || [];
  (t = t ? t.slice(r) : Buffer.allocUnsafe(exports.elst.encodingLength(e))).writeUInt32BE(n.length, 0);
  for (var o = 0; o < n.length; o++) {
    var i = 12 * o + 4;
    t.writeUInt32BE(n[o].trackDuration || 0, i);
    t.writeUInt32BE(n[o].mediaTime || 0, i + 4);
    writeFixed32(n[o].mediaRate || 0, t, i + 8);
  }
  exports.elst.encode.bytes = 4 + 12 * n.length;
  return t;
};

exports.elst.decode = function(e, t) {
  for (var r = (e = e.slice(t)).readUInt32BE(0), n = new Array(r), o = 0; o < r; o++) {
    var i = 12 * o + 4;
    n[o] = {
      trackDuration: e.readUInt32BE(i),
      mediaTime: e.readInt32BE(i + 4),
      mediaRate: readFixed32(e, i + 8)
    };
  }
  return {
    entries: n
  };
};

exports.elst.encodingLength = function(e) {
  return 4 + 12 * e.entries.length;
};

exports.hdlr = {};

exports.hdlr.encode = function(e, t, r) {
  t = t ? t.slice(r) : Buffer.allocUnsafe(exports.hdlr.encodingLength(e));
  var n = 21 + (e.name || "").length;
  t.fill(0, 0, n);
  t.write(e.handlerType || "", 4, 4, "ascii");
  writeString(e.name || "", t, 20);
  exports.hdlr.encode.bytes = n;
  return t;
};

exports.hdlr.decode = function(e, t, r) {
  return {
    handlerType: (e = e.slice(t)).toString("ascii", 4, 8),
    name: readString(e, 20, r)
  };
};

exports.hdlr.encodingLength = function(e) {
  return 21 + (e.name || "").length;
};

exports.mehd = {};

exports.mehd.encode = function(e, t, r) {
  (t = t ? t.slice(r) : Buffer.allocUnsafe(4)).writeUInt32BE(e.fragmentDuration || 0, 0);
  exports.mehd.encode.bytes = 4;
  return t;
};

exports.mehd.decode = function(e, t) {
  return {
    fragmentDuration: (e = e.slice(t)).readUInt32BE(0)
  };
};

exports.mehd.encodingLength = function(e) {
  return 4;
};

exports.trex = {};

exports.trex.encode = function(e, t, r) {
  (t = t ? t.slice(r) : Buffer.allocUnsafe(20)).writeUInt32BE(e.trackId || 0, 0);
  t.writeUInt32BE(e.defaultSampleDescriptionIndex || 0, 4);
  t.writeUInt32BE(e.defaultSampleDuration || 0, 8);
  t.writeUInt32BE(e.defaultSampleSize || 0, 12);
  t.writeUInt32BE(e.defaultSampleFlags || 0, 16);
  exports.trex.encode.bytes = 20;
  return t;
};

exports.trex.decode = function(e, t) {
  return {
    trackId: (e = e.slice(t)).readUInt32BE(0),
    defaultSampleDescriptionIndex: e.readUInt32BE(4),
    defaultSampleDuration: e.readUInt32BE(8),
    defaultSampleSize: e.readUInt32BE(12),
    defaultSampleFlags: e.readUInt32BE(16)
  };
};

exports.trex.encodingLength = function(e) {
  return 20;
};

exports.mfhd = {};

exports.mfhd.encode = function(e, t, r) {
  (t = t ? t.slice(r) : Buffer.allocUnsafe(4)).writeUInt32BE(e.sequenceNumber || 0, 0);
  exports.mfhd.encode.bytes = 4;
  return t;
};

exports.mfhd.decode = function(e, t) {
  return {
    sequenceNumber: e.readUint32BE(0)
  };
};

exports.mfhd.encodingLength = function(e) {
  return 4;
};

exports.tfhd = {};

exports.tfhd.encode = function(e, t, r) {
  (t = t ? t.slice(r) : Buffer.allocUnsafe(4)).writeUInt32BE(e.trackId, 0);
  exports.tfhd.encode.bytes = 4;
  return t;
};

exports.tfhd.decode = function(e, t) {};

exports.tfhd.encodingLength = function(e) {
  return 4;
};

exports.tfdt = {};

exports.tfdt.encode = function(e, t, r) {
  (t = t ? t.slice(r) : Buffer.allocUnsafe(4)).writeUInt32BE(e.baseMediaDecodeTime || 0, 0);
  exports.tfdt.encode.bytes = 4;
  return t;
};

exports.tfdt.decode = function(e, t) {};

exports.tfdt.encodingLength = function(e) {
  return 4;
};

exports.trun = {};

exports.trun.encode = function(e, t, r) {
  (t = t ? t.slice(r) : Buffer.allocUnsafe(8 + 16 * e.entries.length)).writeUInt32BE(e.entries.length, 0);
  t.writeInt32BE(e.dataOffset, 4);
  for (var n = 8, o = 0; o < e.entries.length; o++) {
    var i = e.entries[o];
    t.writeUInt32BE(i.sampleDuration, n);
    t.writeUInt32BE(i.sampleSize, n += 4);
    t.writeUInt32BE(i.sampleFlags, n += 4);
    t.writeUInt32BE(i.sampleCompositionTimeOffset, n += 4);
    n += 4;
  }
  exports.trun.encode.bytes = n;
};

exports.trun.decode = function(e, t) {};

exports.trun.encodingLength = function(e) {
  return 8 + 16 * e.entries.length;
};

exports.mdat = {};

exports.mdat.encode = function(e, t, r) {
  if (e.buffer) {
    e.buffer.copy(t, r);
    exports.mdat.encode.bytes = e.buffer.length;
  } else exports.mdat.encode.bytes = exports.mdat.encodingLength(e);
};

exports.mdat.decode = function(e, t, r) {
  return {
    buffer: Buffer.from(e.slice(t, r))
  };
};

exports.mdat.encodingLength = function(e) {
  return e.buffer ? e.buffer.length : e.contentLength;
};

function writeReserved(e, t, r) {
  for (var n = t; n < r; n++) e[n] = 0;
}

function writeDate(e, t, r) {
  t.writeUInt32BE(Math.floor((e.getTime() + TIME_OFFSET) / 1e3), r);
}

function writeFixed32(e, t, r) {
  t.writeUInt16BE(Math.floor(e) % 65536, r);
  t.writeUInt16BE(Math.floor(256 * e * 256) % 65536, r + 2);
}

function writeFixed16(e, t, r) {
  t[r] = Math.floor(e) % 256;
  t[r + 1] = Math.floor(256 * e) % 256;
}

function writeMatrix(e, t, r) {
  e || (e = [ 0, 0, 0, 0, 0, 0, 0, 0, 0 ]);
  for (var n = 0; n < e.length; n++) writeFixed32(e[n], t, r + 4 * n);
}

function writeString(e, t, r) {
  var n = Buffer.from(e, "utf8");
  n.copy(t, r);
  t[r + n.length] = 0;
}

function readMatrix(e) {
  for (var t = new Array(e.length / 4), r = 0; r < t.length; r++) t[r] = readFixed32(e, 4 * r);
  return t;
}

function readDate(e, t) {
  return new Date(1e3 * e.readUInt32BE(t) - TIME_OFFSET);
}

function readFixed32(e, t) {
  return e.readUInt16BE(t) + e.readUInt16BE(t + 2) / 65536;
}

function readFixed16(e, t) {
  return e[t] + e[t + 1] / 256;
}

function readString(e, t, r) {
  var n;
  for (n = 0; n < r; n++) if (0 === e[t + n]) break;
  return e.toString("utf8", t, t + n);
}
},{"./descriptor":17,"./index":18,"buffer":8}],17:[function(require,module,exports){
var Buffer = require("buffer").Buffer, tagToName = {
  3: "ESDescriptor",
  4: "DecoderConfigDescriptor",
  5: "DecoderSpecificInfo",
  6: "SLConfigDescriptor"
};

exports.Descriptor = {};

exports.Descriptor.decode = function(r, e, o) {
  var t, c, i = r.readUInt8(e), s = e + 1, p = 0;
  do {
    p = p << 7 | 127 & (t = r.readUInt8(s++));
  } while (128 & t);
  var a = tagToName[i];
  (c = exports[a] ? exports[a].decode(r, s, o) : {
    buffer: Buffer.from(r.slice(s, s + p))
  }).tag = i;
  c.tagName = a;
  c.length = s - e + p;
  c.contentsLen = p;
  return c;
};

exports.DescriptorArray = {};

exports.DescriptorArray.decode = function(r, e, o) {
  var t = e, c = {};
  while (t + 2 <= o) {
    var i = exports.Descriptor.decode(r, t, o);
    t += i.length;
    c[tagToName[i.tag] || "Descriptor" + i.tag] = i;
  }
  return c;
};

exports.ESDescriptor = {};

exports.ESDescriptor.decode = function(r, e, o) {
  var t = r.readUInt8(e + 2), c = e + 3;
  128 & t && (c += 2);
  64 & t && (c += r.readUInt8(c) + 1);
  32 & t && (c += 2);
  return exports.DescriptorArray.decode(r, c, o);
};

exports.DecoderConfigDescriptor = {};

exports.DecoderConfigDescriptor.decode = function(r, e, o) {
  var t = r.readUInt8(e), c = exports.DescriptorArray.decode(r, e + 13, o);
  c.oti = t;
  return c;
};
},{"buffer":8}],18:[function(require,module,exports){
var Buffer = require("buffer").Buffer, uint64be = require("uint64be"), boxes = require("./boxes"), UINT32_MAX = 4294967295, Box = exports;

Box.boxes = boxes;

var containers = exports.containers = {
  moov: [ "mvhd", "meta", "traks", "mvex" ],
  trak: [ "tkhd", "tref", "trgr", "edts", "meta", "mdia", "udta" ],
  edts: [ "elst" ],
  mdia: [ "mdhd", "hdlr", "elng", "minf" ],
  minf: [ "vmhd", "smhd", "hmhd", "sthd", "nmhd", "dinf", "stbl" ],
  dinf: [ "dref" ],
  stbl: [ "stsd", "stts", "ctts", "cslg", "stsc", "stsz", "stz2", "stco", "co64", "stss", "stsh", "padb", "stdp", "sdtp", "sbgps", "sgpds", "subss", "saizs", "saios" ],
  mvex: [ "mehd", "trexs", "leva" ],
  moof: [ "mfhd", "meta", "trafs" ],
  traf: [ "tfhd", "tfdt", "trun", "sbgps", "sgpds", "subss", "saizs", "saios", "meta" ]
};

Box.encode = function(e, t, o) {
  Box.encodingLength(e);
  o = o || 0;
  t = t || Buffer.allocUnsafe(e.length);
  return Box._encode(e, t, o);
};

Box._encode = function(o, n, e) {
  var t = o.type, s = o.length;
  s > UINT32_MAX && (s = 1);
  n.writeUInt32BE(s, e);
  n.write(o.type, e + 4, 4, "ascii");
  var r = e + 8;
  if (1 === s) {
    uint64be.encode(o.length, n, r);
    r += 8;
  }
  if (boxes.fullBoxes[t]) {
    n.writeUInt32BE(o.flags || 0, r);
    n.writeUInt8(o.version || 0, r);
    r += 4;
  }
  if (containers[t]) {
    containers[t].forEach(function(e) {
      if (5 === e.length) {
        var t = o[e] || [];
        e = e.substr(0, 4);
        t.forEach(function(e) {
          Box._encode(e, n, r);
          r += Box.encode.bytes;
        });
      } else if (o[e]) {
        Box._encode(o[e], n, r);
        r += Box.encode.bytes;
      }
    });
    o.otherBoxes && o.otherBoxes.forEach(function(e) {
      Box._encode(e, n, r);
      r += Box.encode.bytes;
    });
  } else if (boxes[t]) {
    var f = boxes[t].encode;
    f(o, n, r);
    r += f.bytes;
  } else {
    if (!o.buffer) throw new Error("Either `type` must be set to a known type (not'" + t + "') or `buffer` must be set");
    o.buffer.copy(n, r);
    r += o.buffer.length;
  }
  Box.encode.bytes = r - e;
  return n;
};

Box.readHeaders = function(e, t, o) {
  if ((o = o || e.length) - (t = t || 0) < 8) return 8;
  var n, s, r = e.readUInt32BE(t), f = e.toString("ascii", t + 4, t + 8), i = t + 8;
  if (1 === r) {
    if (o - t < 16) return 16;
    r = uint64be.decode(e, i);
    i += 8;
  }
  d > 1 && console.warn("Box.readHeaders", [ e ], t, o, f, containers[f], boxes[f], boxes.fullBoxes[f]);
  "sidx" === f && (i -= 8);
  if (boxes.fullBoxes[f]) {
    n = e.readUInt8(i);
    s = 16777215 & e.readUInt32BE(i);
    i += 4;
  }
  return {
    length: r,
    headersLen: i - t,
    contentLen: r - (i - t),
    type: f,
    version: n,
    flags: s
  };
};

Box.decode = function(e, t, o) {
  var n = Box.readHeaders(e, t = t || 0, o = o || e.length);
  if (!n || n.length > o - t) throw new Error("Unsupported media format, data too short...");
  return Box.decodeWithoutHeaders(n, e, t + n.headersLen, t + n.length);
};

Box.decodeWithoutHeaders = function(e, t, o, n) {
  o = o || 0;
  n = n || t.length;
  var s = e.type, r = Object.create(null);
  d > 1 && console.warn("Box.decode", s, r);
  if (containers[s]) {
    r.otherBoxes = [];
    var f = containers[s], i = o;
    while (n - i >= 8) {
      var a = Box.decode(t, i, n);
      i += a.length;
      if (f.indexOf(a.type) >= 0) r[a.type] = a; else if (f.indexOf(a.type + "s") >= 0) {
        var c = a.type + "s";
        (r[c] = r[c] || []).push(a);
      } else r.otherBoxes.push(a);
    }
  } else boxes[s] ? r = boxes[s].decode.call(e, t, o, n) : r.buffer = Buffer.from(t.slice(o, n));
  r.length = e.length;
  r.contentLen = e.contentLen;
  r.type = e.type;
  r.version = e.version;
  r.flags = e.flags;
  return r;
};

Box.encodingLength = function(n) {
  var e = n.type, s = 8;
  boxes.fullBoxes[e] && (s += 4);
  if (containers[e]) {
    containers[e].forEach(function(t) {
      if (5 === t.length) {
        var e = n[t] || [];
        t = t.substr(0, 4);
        e.forEach(function(e) {
          e.type = t;
          s += Box.encodingLength(e);
        });
      } else if (n[t]) {
        var o = n[t];
        o.type = t;
        s += Box.encodingLength(o);
      }
    });
    n.otherBoxes && n.otherBoxes.forEach(function(e) {
      s += Box.encodingLength(e);
    });
  } else if (boxes[e]) s += boxes[e].encodingLength(n); else {
    if (!n.buffer) throw new Error("Either `type` must be set to a known type (not'" + e + "') or `buffer` must be set");
    s += n.buffer.length;
  }
  s > UINT32_MAX && (s += 8);
  return n.length = s;
};
},{"./boxes":16,"buffer":8,"uint64be":37}],19:[function(require,module,exports){
var Buffer = require("buffer").Buffer, stream = require("readable-stream"), inherits = require("/bundle/utils").inherit, nextEvent = require("next-event"), Box = require("mp4-box-encoding"), EMPTY = Buffer.allocUnsafe(0);

function Decoder() {
  if (!(this instanceof Decoder)) return new Decoder();
  stream.Writable.call(this);
  this.destroyed = !1;
  this._pending = 0;
  this._missing = 0;
  this._buf = null;
  this._str = null;
  this._cb = null;
  this._ondrain = null;
  this._writeBuffer = null;
  this._writeCb = null;
  this._ondrain = null;
  this._kick();
}

inherits(module.exports = Decoder, stream.Writable);

Decoder.prototype.destroy = function(e) {
  if (!this.destroyed) {
    this.destroyed = !0;
    e && this.emit("error", e);
    this.emit("close");
  }
};

Decoder.prototype._write = function(e, t, i) {
  if (!this.destroyed) {
    var r = !this._str || !this._str._writableState.needDrain;
    while (e.length && !this.destroyed) {
      if (!this._missing) {
        this._writeBuffer = e;
        this._writeCb = i;
        return;
      }
      var s = e.length < this._missing ? e.length : this._missing;
      this._buf ? e.copy(this._buf, this._buf.length - this._missing) : this._str && (r = this._str.write(s === e.length ? e : e.slice(0, s)));
      this._missing -= s;
      if (!this._missing) {
        var n = this._buf, h = this._cb, o = this._str;
        this._buf = this._cb = this._str = this._ondrain = null;
        r = !0;
        o && o.end();
        h && h(n);
      }
      e = s === e.length ? EMPTY : e.slice(s);
    }
    if (!this._pending || this._missing) r ? i() : this._ondrain(i); else {
      this._writeBuffer = e;
      this._writeCb = i;
    }
  }
};

Decoder.prototype._buffer = function(e, t) {
  this._missing = e;
  this._buf = Buffer.allocUnsafe(e);
  this._cb = t;
};

Decoder.prototype._stream = function(e, t) {
  var i = this;
  this._missing = e;
  this._str = new MediaData(this);
  this._ondrain = nextEvent(this._str, "drain");
  this._pending++;
  this._str.on("end", function() {
    i._pending--;
    i._kick();
  });
  this._cb = t;
  return this._str;
};

Decoder.prototype._readBox = function() {
  var r = this;
  !function bufferHeaders(e, i) {
    r._buffer(e, function(e) {
      i = i ? Buffer.concat([ i, e ]) : e;
      var t = Box.readHeaders(i);
      if ("number" === typeof t) bufferHeaders(t - i.length, i); else {
        r._pending++;
        r._headers = t;
        r.emit("box", t);
      }
    });
  }(8);
};

Decoder.prototype.stream = function() {
  var e = this;
  if (!e._headers) throw new Error("this function can only be called once after 'box' is emitted");
  var t = e._headers;
  e._headers = null;
  return e._stream(t.contentLen, null);
};

Decoder.prototype.decode = function(i) {
  var r = this;
  if (!r._headers) throw new Error("this function can only be called once after 'box' is emitted");
  var s = r._headers;
  r._headers = null;
  r._buffer(s.contentLen, function(e) {
    var t = Box.decodeWithoutHeaders(s, e);
    i(t);
    r._pending--;
    r._kick();
  });
};

Decoder.prototype.ignore = function() {
  var e = this;
  if (!e._headers) throw new Error("this function can only be called once after 'box' is emitted");
  var t = e._headers;
  e._headers = null;
  this._missing = t.contentLen;
  this._cb = function() {
    e._pending--;
    e._kick();
  };
};

Decoder.prototype._kick = function() {
  if (!this._pending) {
    this._buf || this._str || this._readBox();
    if (this._writeBuffer) {
      var e = this._writeCb, t = this._writeBuffer;
      this._writeBuffer = null;
      this._writeCb = null;
      this._write(t, null, e);
    }
  }
};

function MediaData(e) {
  this._parent = e;
  this.destroyed = !1;
  stream.PassThrough.call(this);
}

inherits(MediaData, stream.PassThrough);

MediaData.prototype.destroy = function(e) {
  if (!this.destroyed) {
    this.destroyed = !0;
    this._parent.destroy(e);
    e && this.emit("error", e);
    this.emit("close");
  }
};
},{"/bundle/utils":3,"buffer":8,"mp4-box-encoding":18,"next-event":22,"readable-stream":35}],20:[function(require,module,exports){
var stream = require("readable-stream"), inherits = require("/bundle/utils").inherit, Box = require("mp4-box-encoding");

module.exports = Encoder;

var nextTick = require("/bundle/utils").nextTick, Buffer = require("buffer").Buffer;

function noop() {}

function Encoder() {
  if (!(this instanceof Encoder)) return new Encoder();
  stream.Readable.call(this);
  this.destroyed = !1;
  this._reading = !1;
  this._stream = null;
  this._drain = null;
  this._want = !1;
  this._onreadable = function() {
    if (e._want) {
      e._want = !1;
      e._read();
    }
  };
  this._onend = function() {
    e._stream = null;
  };
  var e = this;
}

inherits(Encoder, stream.Readable);

Encoder.prototype.mediaData = Encoder.prototype.mdat = function(e, t) {
  var r = new MediaData(this);
  this.box({
    type: "mdat",
    contentLength: e,
    encodeBufferLen: 8,
    stream: r
  }, t);
  return r;
};

Encoder.prototype.box = function(e, t) {
  t || (t = noop);
  if (this.destroyed) return t(new Error("Encoder is destroyed"));
  var r;
  e.encodeBufferLen && (r = Buffer.allocUnsafe(e.encodeBufferLen));
  if (e.stream) {
    e.buffer = null;
    r = Box.encode(e, r);
    this.push(r);
    this._stream = e.stream;
    this._stream.on("readable", this._onreadable);
    this._stream.on("end", this._onend);
    this._stream.on("end", t);
    this._forward();
  } else {
    r = Box.encode(e, r);
    if (this.push(r)) return nextTick(t);
    this._drain = t;
  }
};

Encoder.prototype.destroy = function(e) {
  if (!this.destroyed) {
    this.destroyed = !0;
    this._stream && this._stream.destroy && this._stream.destroy();
    this._stream = null;
    if (this._drain) {
      var t = this._drain;
      this._drain = null;
      t(e);
    }
    e && this.emit("error", e);
    this.emit("close");
  }
};

Encoder.prototype.finalize = function() {
  this.push(null);
};

Encoder.prototype._forward = function() {
  if (this._stream) while (!this.destroyed) {
    var e = this._stream.read();
    if (!e) {
      this._want = !!this._stream;
      return;
    }
    if (!this.push(e)) return;
  }
};

Encoder.prototype._read = function() {
  if (!this._reading && !this.destroyed) {
    this._reading = !0;
    this._stream && this._forward();
    if (this._drain) {
      var e = this._drain;
      this._drain = null;
      e();
    }
    this._reading = !1;
  }
};

function MediaData(e) {
  this._parent = e;
  this.destroyed = !1;
  stream.PassThrough.call(this);
}

inherits(MediaData, stream.PassThrough);

MediaData.prototype.destroy = function(e) {
  if (!this.destroyed) {
    this.destroyed = !0;
    this._parent.destroy(e);
    e && this.emit("error", e);
    this.emit("close");
  }
};
},{"/bundle/utils":3,"buffer":8,"mp4-box-encoding":18,"readable-stream":35}],21:[function(require,module,exports){
exports.decode = require("./decode");

exports.encode = require("./encode");
},{"./decode":19,"./encode":20}],22:[function(require,module,exports){
module.exports = nextEvent;

function nextEvent(n, t) {
  var e = null;
  n.on(t, function(n) {
    if (e) {
      var t = e;
      e = null;
      t(n);
    }
  });
  return function(n) {
    e = n;
  };
}
},{}],23:[function(require,module,exports){
var wrappy = require("wrappy");

module.exports = wrappy(once);

module.exports.strict = wrappy(onceStrict);

once.proto = once(function() {
  Object.defineProperty(Function.prototype, "once", {
    value: function() {
      return once(this);
    },
    configurable: !0
  });
  Object.defineProperty(Function.prototype, "onceStrict", {
    value: function() {
      return onceStrict(this);
    },
    configurable: !0
  });
});

function once(e) {
  var r = function() {
    if (r.called) return r.value;
    r.called = !0;
    return r.value = e.apply(this, arguments);
  };
  r.called = !1;
  return r;
}

function onceStrict(e) {
  var r = function() {
    if (r.called) throw new Error(r.onceError);
    r.called = !0;
    return r.value = e.apply(this, arguments);
  };
  r.onceError = (e.name || "Function wrapped with `once`") + " shouldn't be called more than once";
  r.called = !1;
  return r;
}
},{"wrappy":38}],24:[function(require,module,exports){
var isFS, once = require("once"), eos = require("end-of-stream"), noop = function() {}, isFn = function(r) {
  return "function" === typeof r;
}, isRequest = function(r) {
  return r.setHeader && isFn(r.abort);
}, destroyer = function(e, r, n, o) {
  o = once(o);
  var t = !1;
  e.on("close", function() {
    t = !0;
  });
  eos(e, {
    readable: r,
    writable: n
  }, function(r) {
    if (r) return o(r);
    t = !0;
    o();
  });
  var i = !1;
  return function(r) {
    if (!t && !i) {
      i = !0;
      if (isRequest(e)) return e.abort();
      if (isFn(e.destroy)) return e.destroy();
      o(r || new Error("stream was destroyed"));
    }
  };
}, call = function(r) {
  r();
}, pipe = function(r, e) {
  return r.pipe(e);
}, pump = function() {
  var r = arguments.length, o = new Array(r);
  while (r--) o[r] = arguments[r];
  var t, i = isFn(o[o.length - 1] || noop) && o.pop() || noop;
  Array.isArray(o[0]) && (o = o[0]);
  if (o.length < 2) throw new Error("pump requires two streams per minimum");
  var u = o.map(function(r, e) {
    var n = e < o.length - 1;
    return destroyer(r, n, e > 0, function(r) {
      t || (t = r);
      r && u.forEach(call);
      if (!n) {
        u.forEach(call);
        i(t);
      }
    });
  });
  return o.reduce(pipe);
};

module.exports = pump;
},{"end-of-stream":12,"once":23}],25:[function(require,module,exports){
var inherits = require("/bundle/utils").inherit, stream = require("readable-stream");

inherits(module.exports = RangeSliceStream, stream.Writable);

function RangeSliceStream(e, t) {
  var r = this;
  if (!(r instanceof RangeSliceStream)) return new RangeSliceStream(e);
  stream.Writable.call(r, t);
  r.destroyed = !1;
  r._queue = [];
  r._position = e || 0;
  r._cb = null;
  r._buffer = null;
  r._out = null;
}

RangeSliceStream.prototype._write = function(e, t, r) {
  var n = this, i = !0;
  while (1) {
    if (n.destroyed) return;
    if (0 === n._queue.length) {
      n._buffer = e;
      n._cb = r;
      return;
    }
    n._buffer = null;
    var a, l = n._queue[0], s = Math.max(l.start - n._position, 0), u = l.end - n._position;
    if (s >= e.length) {
      n._position += e.length;
      return r(null);
    }
    if (u > e.length) {
      n._position += e.length;
      a = 0 === s ? e : e.slice(s);
      i = l.stream.write(a) && i;
      break;
    }
    n._position += u;
    a = 0 === s && u === e.length ? e : e.slice(s, u);
    i = l.stream.write(a) && i;
    l.last && l.stream.end();
    e = e.slice(u);
    n._queue.shift();
  }
  i ? r(null) : l.stream.once("drain", r.bind(null, null));
};

RangeSliceStream.prototype.slice = function(r) {
  var n = this;
  if (n.destroyed) return null;
  r instanceof Array || (r = [ r ]);
  var i = new stream.PassThrough();
  r.forEach(function(e, t) {
    n._queue.push({
      start: e.start,
      end: e.end,
      stream: i,
      last: t === r.length - 1
    });
  });
  n._buffer && n._write(n._buffer, null, n._cb);
  return i;
};

RangeSliceStream.prototype.destroy = function(e) {
  var t = this;
  if (!t.destroyed) {
    t.destroyed = !0;
    e && t.emit("error", e);
  }
};
},{"/bundle/utils":3,"readable-stream":35}],26:[function(require,module,exports){
"use strict";

var pna = require("/bundle/utils"), objectKeys = Object.keys;

module.exports = Duplex;

var inherits = require("/bundle/utils").inherit, Readable = require("./_stream_readable"), Writable = require("./_stream_writable");

inherits(Duplex, Readable);

for (var keys = objectKeys(Writable.prototype), v = 0; v < keys.length; v++) {
  var method = keys[v];
  Duplex.prototype[method] || (Duplex.prototype[method] = Writable.prototype[method]);
}

function Duplex(e) {
  if (!(this instanceof Duplex)) return new Duplex(e);
  Readable.call(this, e);
  Writable.call(this, e);
  e && !1 === e.readable && (this.readable = !1);
  e && !1 === e.writable && (this.writable = !1);
  this.allowHalfOpen = !0;
  e && !1 === e.allowHalfOpen && (this.allowHalfOpen = !1);
  this.once("end", onend);
}

Object.defineProperty(Duplex.prototype, "writableHighWaterMark", {
  enumerable: !1,
  get: function() {
    return this._writableState.highWaterMark;
  }
});

function onend() {
  this.allowHalfOpen || this._writableState.ended || pna.nextTick(onEndNT, this);
}

function onEndNT(e) {
  e.end();
}

Object.defineProperty(Duplex.prototype, "destroyed", {
  get: function() {
    return void 0 !== this._readableState && void 0 !== this._writableState && this._readableState.destroyed && this._writableState.destroyed;
  },
  set: function(e) {
    if (void 0 !== this._readableState && void 0 !== this._writableState) {
      this._readableState.destroyed = e;
      this._writableState.destroyed = e;
    }
  }
});

Duplex.prototype._destroy = function(e, t) {
  this.push(null);
  this.end();
  pna.nextTick(t, e);
};
},{"./_stream_readable":28,"./_stream_writable":30,"/bundle/utils":3}],27:[function(require,module,exports){
"use strict";

module.exports = PassThrough;

var Transform = require("./_stream_transform"), inherits = require("/bundle/utils").inherit;

inherits(PassThrough, Transform);

function PassThrough(r) {
  if (!(this instanceof PassThrough)) return new PassThrough(r);
  Transform.call(this, r);
}

PassThrough.prototype._transform = function(r, s, o) {
  o(null, r);
};
},{"./_stream_transform":29,"/bundle/utils":3}],28:[function(require,module,exports){
"use strict";

var pna = require("/bundle/utils");

module.exports = Readable;

var Duplex, isArray = Array.isArray;

Readable.ReadableState = ReadableState;

var StringDecoder, EE = require("eventemitter3").EventEmitter, EElistenerCount = function(e, t) {
  return e.listeners(t).length;
}, Stream = require("./internal/streams/stream"), _isUint8Array = require("/bundle/utils").isU8, Buffer = require("buffer").Buffer, inherits = require("/bundle/utils").inherit, debug = require("/bundle/utils").debuglog("stream"), BufferList = require("./internal/streams/BufferList"), destroyImpl = require("./internal/streams/destroy");

inherits(Readable, Stream);

var kProxyEvents = [ "error", "close", "destroy", "pause", "resume" ];

function prependListener(e, t, n) {
  if ("function" === typeof e.prependListener) return e.prependListener(t, n);
  e._events && e._events[t] ? isArray(e._events[t]) ? e._events[t].unshift(n) : e._events[t] = [ n, e._events[t] ] : e.on(t, n);
}

function ReadableState(e, t) {
  var n = t instanceof (Duplex = Duplex || require("./_stream_duplex"));
  this.objectMode = !!(e = e || {}).objectMode;
  n && (this.objectMode = this.objectMode || !!e.readableObjectMode);
  var r = e.highWaterMark, i = e.readableHighWaterMark;
  this.highWaterMark = r || 0 === r ? r : n && (i || 0 === i) ? i : this.objectMode ? 16 : 16384;
  this.highWaterMark = Math.floor(this.highWaterMark);
  this.buffer = new BufferList();
  this.length = 0;
  this.pipes = null;
  this.pipesCount = 0;
  this.flowing = null;
  this.ended = !1;
  this.endEmitted = !1;
  this.reading = !1;
  this.sync = !0;
  this.needReadable = !1;
  this.emittedReadable = !1;
  this.readableListening = !1;
  this.resumeScheduled = !1;
  this.destroyed = !1;
  this.defaultEncoding = e.defaultEncoding || "utf8";
  this.awaitDrain = 0;
  this.readingMore = !1;
  this.decoder = null;
  this.encoding = null;
  if (e.encoding) {
    StringDecoder || (StringDecoder = require("string_decoder/").StringDecoder);
    this.decoder = new StringDecoder(e.encoding);
    this.encoding = e.encoding;
  }
}

function Readable(e) {
  Duplex = Duplex || require("./_stream_duplex");
  if (!(this instanceof Readable)) return new Readable(e);
  this._readableState = new ReadableState(e, this);
  this.readable = !0;
  if (e) {
    "function" === typeof e.read && (this._read = e.read);
    "function" === typeof e.destroy && (this._destroy = e.destroy);
  }
  Stream.call(this);
}

Object.defineProperty(Readable.prototype, "destroyed", {
  get: function() {
    return void 0 !== this._readableState && this._readableState.destroyed;
  },
  set: function(e) {
    this._readableState && (this._readableState.destroyed = e);
  }
});

Readable.prototype.destroy = destroyImpl.destroy;

Readable.prototype._undestroy = destroyImpl.undestroy;

Readable.prototype._destroy = function(e, t) {
  this.push(null);
  t(e);
};

Readable.prototype.push = function(e, t) {
  var n, r = this._readableState;
  if (r.objectMode) n = !0; else if ("string" === typeof e) {
    if ((t = t || r.defaultEncoding) !== r.encoding) {
      e = Buffer.from(e, t);
      t = "";
    }
    n = !0;
  }
  return readableAddChunk(this, e, t, !1, n);
};

Readable.prototype.unshift = function(e) {
  return readableAddChunk(this, e, null, !0, !1);
};

function readableAddChunk(e, t, n, r, i) {
  var a = e._readableState;
  if (null === t) {
    a.reading = !1;
    onEofChunk(e, a);
  } else {
    var d;
    i || (d = chunkInvalid(a, t));
    if (d) e.emit("error", d); else if (a.objectMode || t && t.length > 0) {
      "string" === typeof t || a.objectMode || Object.getPrototypeOf(t) === Buffer.prototype || (t = Buffer.from(t));
      if (r) a.endEmitted ? e.emit("error", new Error("stream.unshift() after end event")) : addChunk(e, a, t, !0); else if (a.ended) e.emit("error", new Error("stream.push() after EOF")); else {
        a.reading = !1;
        if (a.decoder && !n) {
          t = a.decoder.write(t);
          a.objectMode || 0 !== t.length ? addChunk(e, a, t, !1) : maybeReadMore(e, a);
        } else addChunk(e, a, t, !1);
      }
    } else r || (a.reading = !1);
  }
  return needMoreData(a);
}

function addChunk(e, t, n, r) {
  if (t.flowing && 0 === t.length && !t.sync) {
    e.emit("data", n);
    e.read(0);
  } else {
    t.length += t.objectMode ? 1 : n.length;
    r ? t.buffer.unshift(n) : t.buffer.push(n);
    t.needReadable && emitReadable(e);
  }
  maybeReadMore(e, t);
}

function chunkInvalid(e, t) {
  var n;
  _isUint8Array(t) || "string" === typeof t || void 0 === t || e.objectMode || (n = new TypeError("Invalid non-string/buffer chunk"));
  return n;
}

function needMoreData(e) {
  return !e.ended && (e.needReadable || e.length < e.highWaterMark || 0 === e.length);
}

Readable.prototype.isPaused = function() {
  return !1 === this._readableState.flowing;
};

Readable.prototype.setEncoding = function(e) {
  StringDecoder || (StringDecoder = require("string_decoder/").StringDecoder);
  this._readableState.decoder = new StringDecoder(e);
  this._readableState.encoding = e;
  return this;
};

var MAX_HWM = 8388608;

function computeNewHighWaterMark(e) {
  if (e >= MAX_HWM) e = MAX_HWM; else {
    e--;
    e |= e >>> 1;
    e |= e >>> 2;
    e |= e >>> 4;
    e |= e >>> 8;
    e |= e >>> 16;
    e++;
  }
  return e;
}

function howMuchToRead(e, t) {
  if (e <= 0 || 0 === t.length && t.ended) return 0;
  if (t.objectMode) return 1;
  if (e !== e) return t.flowing && t.length ? t.buffer.head.data.length : t.length;
  e > t.highWaterMark && (t.highWaterMark = computeNewHighWaterMark(e));
  if (e <= t.length) return e;
  if (!t.ended) {
    t.needReadable = !0;
    return 0;
  }
  return t.length;
}

Readable.prototype.read = function(e) {
  e = parseInt(e, 10);
  var t = this._readableState, n = e;
  0 !== e && (t.emittedReadable = !1);
  if (0 === e && t.needReadable && (t.length >= t.highWaterMark || t.ended)) {
    0 === t.length && t.ended ? endReadable(this) : emitReadable(this);
    return null;
  }
  if (0 === (e = howMuchToRead(e, t)) && t.ended) {
    0 === t.length && endReadable(this);
    return null;
  }
  var r, i = t.needReadable;
  (0 === t.length || t.length - e < t.highWaterMark) && (i = !0);
  if (t.ended || t.reading) i = !1; else if (i) {
    t.reading = !0;
    t.sync = !0;
    0 === t.length && (t.needReadable = !0);
    this._read(t.highWaterMark);
    t.sync = !1;
    t.reading || (e = howMuchToRead(n, t));
  }
  if (null === (r = e > 0 ? fromList(e, t) : null)) {
    t.needReadable = !0;
    e = 0;
  } else t.length -= e;
  if (0 === t.length) {
    t.ended || (t.needReadable = !0);
    n !== e && t.ended && endReadable(this);
  }
  null !== r && this.emit("data", r);
  return r;
};

function onEofChunk(e, t) {
  if (!t.ended) {
    if (t.decoder) {
      var n = t.decoder.end();
      if (n && n.length) {
        t.buffer.push(n);
        t.length += t.objectMode ? 1 : n.length;
      }
    }
    t.ended = !0;
    emitReadable(e);
  }
}

function emitReadable(e) {
  var t = e._readableState;
  t.needReadable = !1;
  if (!t.emittedReadable) {
    t.emittedReadable = !0;
    t.sync ? pna.nextTick(emitReadable_, e) : emitReadable_(e);
  }
}

function emitReadable_(e) {
  e.emit("readable");
  flow(e);
}

function maybeReadMore(e, t) {
  if (!t.readingMore) {
    t.readingMore = !0;
    pna.nextTick(maybeReadMore_, e, t);
  }
}

function maybeReadMore_(e, t) {
  var n = t.length;
  while (!t.reading && !t.flowing && !t.ended && t.length < t.highWaterMark) {
    e.read(0);
    if (n === t.length) break;
    n = t.length;
  }
  t.readingMore = !1;
}

Readable.prototype._read = function(e) {
  this.emit("error", new Error("_read() is not implemented"));
};

Readable.prototype.pipe = function(n, e) {
  var r = this, i = this._readableState;
  switch (i.pipesCount) {
   case 0:
    i.pipes = n;
    break;

   case 1:
    i.pipes = [ i.pipes, n ];
    break;

   default:
    i.pipes.push(n);
  }
  i.pipesCount += 1;
  var t = e && !1 === e.end ? unpipe : onend;
  i.endEmitted ? pna.nextTick(t) : r.once("end", t);
  n.on("unpipe", function onunpipe(e, t) {
    if (e === r && t && !1 === t.hasUnpiped) {
      t.hasUnpiped = !0;
      !function() {
        n.removeListener("close", onclose);
        n.removeListener("finish", onfinish);
        n.removeListener("drain", a);
        n.removeListener("error", onerror);
        n.removeListener("unpipe", onunpipe);
        r.removeListener("end", onend);
        r.removeListener("end", unpipe);
        r.removeListener("data", ondata);
        d = !0;
        !i.awaitDrain || n._writableState && !n._writableState.needDrain || a();
      }();
    }
  });
  function onend() {
    n.end();
  }
  var a = pipeOnDrain(r);
  n.on("drain", a);
  var d = !1, o = !1;
  r.on("data", ondata);
  function ondata(e) {
    if ((o = !1) === n.write(e) && !o) {
      if ((1 === i.pipesCount && i.pipes === n || i.pipesCount > 1 && -1 !== indexOf(i.pipes, n)) && !d) {
        r._readableState.awaitDrain++;
        o = !0;
      }
      r.pause();
    }
  }
  function onerror(e) {
    unpipe();
    n.removeListener("error", onerror);
    0 === EElistenerCount(n, "error") && n.emit("error", e);
  }
  n.on("error", onerror, 0, !0);
  function onclose() {
    n.removeListener("finish", onfinish);
    unpipe();
  }
  n.once("close", onclose);
  function onfinish() {
    n.removeListener("close", onclose);
    unpipe();
  }
  n.once("finish", onfinish);
  function unpipe() {
    r.unpipe(n);
  }
  n.emit("pipe", r);
  i.flowing || r.resume();
  return n;
};

function pipeOnDrain(t) {
  return function() {
    var e = t._readableState;
    e.awaitDrain && e.awaitDrain--;
    if (0 === e.awaitDrain && EElistenerCount(t, "data")) {
      e.flowing = !0;
      flow(t);
    }
  };
}

Readable.prototype.unpipe = function(e) {
  var t = this._readableState, n = {
    hasUnpiped: !1
  };
  if (0 === t.pipesCount) return this;
  if (1 === t.pipesCount) {
    if (e && e !== t.pipes) return this;
    e || (e = t.pipes);
    t.pipes = null;
    t.pipesCount = 0;
    t.flowing = !1;
    e && e.emit("unpipe", this, n);
    return this;
  }
  if (!e) {
    var r = t.pipes, i = t.pipesCount;
    t.pipes = null;
    t.pipesCount = 0;
    t.flowing = !1;
    for (var a = 0; a < i; a++) r[a].emit("unpipe", this, n);
    return this;
  }
  var d = indexOf(t.pipes, e);
  if (-1 === d) return this;
  t.pipes.splice(d, 1);
  t.pipesCount -= 1;
  1 === t.pipesCount && (t.pipes = t.pipes[0]);
  e.emit("unpipe", this, n);
  return this;
};

Readable.prototype.on = function(e, t) {
  var n = Stream.prototype.on.call(this, e, t);
  if ("data" === e) !1 !== this._readableState.flowing && this.resume(); else if ("readable" === e) {
    var r = this._readableState;
    if (!r.endEmitted && !r.readableListening) {
      r.readableListening = r.needReadable = !0;
      r.emittedReadable = !1;
      r.reading ? r.length && emitReadable(this) : pna.nextTick(nReadingNextTick, this);
    }
  }
  return n;
};

Readable.prototype.addListener = Readable.prototype.on;

function nReadingNextTick(e) {
  e.read(0);
}

Readable.prototype.resume = function() {
  var e = this._readableState;
  if (!e.flowing) {
    e.flowing = !0;
    resume(this, e);
  }
  return this;
};

function resume(e, t) {
  if (!t.resumeScheduled) {
    t.resumeScheduled = !0;
    pna.nextTick(resume_, e, t);
  }
}

function resume_(e, t) {
  t.reading || e.read(0);
  t.resumeScheduled = !1;
  t.awaitDrain = 0;
  e.emit("resume");
  flow(e);
  t.flowing && !t.reading && e.read(0);
}

Readable.prototype.pause = function() {
  if (!1 !== this._readableState.flowing) {
    this._readableState.flowing = !1;
    this.emit("pause");
  }
  return this;
};

function flow(e) {
  var t = e._readableState;
  while (t.flowing && null !== e.read()) ;
}

Readable.prototype.wrap = function(t) {
  var n = this, r = this._readableState, i = !1;
  t.on("end", function() {
    if (r.decoder && !r.ended) {
      var e = r.decoder.end();
      e && e.length && n.push(e);
    }
    n.push(null);
  });
  t.on("data", function(e) {
    r.decoder && (e = r.decoder.write(e));
    if ((!r.objectMode || null !== e && void 0 !== e) && (r.objectMode || e && e.length) && !n.push(e)) {
      i = !0;
      t.pause();
    }
  });
  for (var e in t) void 0 === this[e] && "function" === typeof t[e] && (this[e] = function(e) {
    return function() {
      return t[e].apply(t, arguments);
    };
  }(e));
  for (var a = 0; a < kProxyEvents.length; a++) t.on(kProxyEvents[a], this.emit.bind(this, kProxyEvents[a]));
  this._read = function(e) {
    if (i) {
      i = !1;
      t.resume();
    }
  };
  return this;
};

Object.defineProperty(Readable.prototype, "readableHighWaterMark", {
  enumerable: !1,
  get: function() {
    return this._readableState.highWaterMark;
  }
});

Readable._fromList = fromList;

function fromList(e, t) {
  if (0 === t.length) return null;
  var n;
  if (t.objectMode) n = t.buffer.shift(); else if (!e || e >= t.length) {
    n = t.decoder ? t.buffer.join("") : 1 === t.buffer.length ? t.buffer.head.data : t.buffer.concat(t.length);
    t.buffer.clear();
  } else n = fromListPartial(e, t.buffer, t.decoder);
  return n;
}

function fromListPartial(e, t, n) {
  var r;
  if (e < t.head.data.length) {
    r = t.head.data.slice(0, e);
    t.head.data = t.head.data.slice(e);
  } else r = e === t.head.data.length ? t.shift() : n ? copyFromBufferString(e, t) : copyFromBuffer(e, t);
  return r;
}

function copyFromBufferString(e, t) {
  var n = t.head, r = 1, i = n.data;
  e -= i.length;
  while (n = n.next) {
    var a = n.data, d = e > a.length ? a.length : e;
    i += d === a.length ? a : a.slice(0, e);
    if (0 === (e -= d)) {
      if (d === a.length) {
        ++r;
        t.head = n.next ? n.next : t.tail = null;
      } else (t.head = n).data = a.slice(d);
      break;
    }
    ++r;
  }
  t.length -= r;
  return i;
}

function copyFromBuffer(e, t) {
  var n = Buffer.allocUnsafe(e), r = t.head, i = 1;
  r.data.copy(n);
  e -= r.data.length;
  while (r = r.next) {
    var a = r.data, d = e > a.length ? a.length : e;
    a.copy(n, n.length - e, 0, d);
    if (0 === (e -= d)) {
      if (d === a.length) {
        ++i;
        t.head = r.next ? r.next : t.tail = null;
      } else (t.head = r).data = a.slice(d);
      break;
    }
    ++i;
  }
  t.length -= i;
  return n;
}

function endReadable(e) {
  var t = e._readableState;
  if (t.length > 0) throw new Error('"endReadable()" called on non-empty stream');
  if (!t.endEmitted) {
    t.ended = !0;
    pna.nextTick(endReadableNT, t, e);
  }
}

function endReadableNT(e, t) {
  if (!e.endEmitted && 0 === e.length) {
    t.readable = !(e.endEmitted = !0);
    t.emit("end");
  }
}

function indexOf(e, t) {
  for (var n = 0, r = e.length; n < r; n++) if (e[n] === t) return n;
  return -1;
}
},{"./_stream_duplex":26,"./internal/streams/BufferList":31,"./internal/streams/destroy":32,"./internal/streams/stream":33,"/bundle/utils":3,"buffer":8,"eventemitter3":13,"string_decoder/":34}],29:[function(require,module,exports){
"use strict";

module.exports = Transform;

var Duplex = require("./_stream_duplex"), inherits = require("/bundle/utils").inherit;

inherits(Transform, Duplex);

function afterTransform(r, t) {
  var e = this._transformState;
  e.transforming = !1;
  var n = e.writecb;
  if (!n) return this.emit("error", new Error("write callback called multiple times"));
  e.writechunk = null;
  (e.writecb = null) != t && this.push(t);
  n(r);
  var i = this._readableState;
  i.reading = !1;
  (i.needReadable || i.length < i.highWaterMark) && this._read(i.highWaterMark);
}

function Transform(r) {
  if (!(this instanceof Transform)) return new Transform(r);
  Duplex.call(this, r);
  this._transformState = {
    afterTransform: afterTransform.bind(this),
    needTransform: !1,
    transforming: !1,
    writecb: null,
    writechunk: null,
    writeencoding: null
  };
  this._readableState.needReadable = !0;
  this._readableState.sync = !1;
  if (r) {
    "function" === typeof r.transform && (this._transform = r.transform);
    "function" === typeof r.flush && (this._flush = r.flush);
  }
  this.on("prefinish", prefinish);
}

function prefinish() {
  var e = this;
  "function" === typeof this._flush ? this._flush(function(r, t) {
    done(e, r, t);
  }) : done(this, null, null);
}

Transform.prototype.push = function(r, t) {
  this._transformState.needTransform = !1;
  return Duplex.prototype.push.call(this, r, t);
};

Transform.prototype._transform = function(r, t, e) {
  throw new Error("_transform() is not implemented");
};

Transform.prototype._write = function(r, t, e) {
  var n = this._transformState;
  n.writecb = e;
  n.writechunk = r;
  n.writeencoding = t;
  if (!n.transforming) {
    var i = this._readableState;
    (n.needTransform || i.needReadable || i.length < i.highWaterMark) && this._read(i.highWaterMark);
  }
};

Transform.prototype._read = function(r) {
  var t = this._transformState;
  if (null !== t.writechunk && t.writecb && !t.transforming) {
    t.transforming = !0;
    this._transform(t.writechunk, t.writeencoding, t.afterTransform);
  } else t.needTransform = !0;
};

Transform.prototype._destroy = function(r, t) {
  var e = this;
  Duplex.prototype._destroy.call(this, r, function(r) {
    t(r);
    e.emit("close");
  });
};

function done(r, t, e) {
  if (t) return r.emit("error", t);
  null != e && r.push(e);
  if (r._writableState.length) throw new Error("Calling transform done when ws.length != 0");
  if (r._transformState.transforming) throw new Error("Calling transform done when still transforming");
  return r.push(null);
}
},{"./_stream_duplex":26,"/bundle/utils":3}],30:[function(require,module,exports){
"use strict";

var pna = require("/bundle/utils");

module.exports = Writable;

function WriteReq(e, t, i) {
  this.chunk = e;
  this.encoding = t;
  this.callback = i;
  this.next = null;
}

function CorkedRequest(e) {
  var t = this;
  this.next = null;
  this.entry = null;
  this.finish = function() {
    onCorkedFinish(t, e);
  };
}

var Duplex, asyncWrite = require("/bundle/utils").nextTick;

Writable.WritableState = WritableState;

var realHasInstance, inherits = require("/bundle/utils").inherit, deprecate = require("/bundle/utils").deprecate, Stream = require("./internal/streams/stream"), _isUint8Array = require("/bundle/utils").isU8, Buffer = require("buffer").Buffer, destroyImpl = require("./internal/streams/destroy");

inherits(Writable, Stream);

function nop() {}

function WritableState(e, t) {
  Duplex = Duplex || require("./_stream_duplex");
  var i = t instanceof Duplex;
  this.objectMode = !!(e = e || {}).objectMode;
  i && (this.objectMode = this.objectMode || !!e.writableObjectMode);
  var r = e.highWaterMark, n = e.writableHighWaterMark;
  this.highWaterMark = r || 0 === r ? r : i && (n || 0 === n) ? n : this.objectMode ? 16 : 16384;
  this.highWaterMark = Math.floor(this.highWaterMark);
  this.finalCalled = !1;
  this.needDrain = !1;
  this.ending = !1;
  this.ended = !1;
  this.finished = !1;
  this.destroyed = !1;
  this.decodeStrings = !(!1 === e.decodeStrings);
  this.defaultEncoding = e.defaultEncoding || "utf8";
  this.length = 0;
  this.writing = !1;
  this.corked = 0;
  this.sync = !0;
  this.bufferProcessing = !1;
  this.onwrite = function(e) {
    onwrite(t, e);
  };
  this.writecb = null;
  this.writelen = 0;
  this.bufferedRequest = null;
  this.lastBufferedRequest = null;
  this.pendingcb = 0;
  this.prefinished = !1;
  this.errorEmitted = !1;
  this.bufferedRequestCount = 0;
  this.corkedRequestsFree = new CorkedRequest(this);
}

WritableState.prototype.getBuffer = function() {
  var e = this.bufferedRequest, t = [];
  while (e) {
    t.push(e);
    e = e.next;
  }
  return t;
};

!function() {
  try {
    Object.defineProperty(WritableState.prototype, "buffer", {
      get: deprecate(function() {
        return this.getBuffer();
      }, "_writableState.buffer is deprecated. Use _writableState.getBuffer instead.", "DEP0003")
    });
  } catch (e) {}
}();

if ("function" === typeof Symbol && Symbol.hasInstance && "function" === typeof Function.prototype[Symbol.hasInstance]) {
  realHasInstance = Function.prototype[Symbol.hasInstance];
  Object.defineProperty(Writable, Symbol.hasInstance, {
    value: function(e) {
      return !!realHasInstance.call(this, e) || this === Writable && e && e._writableState instanceof WritableState;
    }
  });
} else realHasInstance = function(e) {
  return e instanceof this;
};

function Writable(e) {
  Duplex = Duplex || require("./_stream_duplex");
  if (!realHasInstance.call(Writable, this) && !(this instanceof Duplex)) return new Writable(e);
  this._writableState = new WritableState(e, this);
  this.writable = !0;
  if (e) {
    "function" === typeof e.write && (this._write = e.write);
    "function" === typeof e.writev && (this._writev = e.writev);
    "function" === typeof e.destroy && (this._destroy = e.destroy);
    "function" === typeof e.final && (this._final = e.final);
  }
  Stream.call(this);
}

Writable.prototype.pipe = function() {
  this.emit("error", new Error("Cannot pipe, not readable"));
};

function writeAfterEnd(e, t) {
  var i = new Error("write after end");
  e.emit("error", i);
  pna.nextTick(t, i);
}

function validChunk(e, t, i, r) {
  var n = !0, o = !1;
  null === i ? o = new TypeError("May not write null values to stream") : "string" === typeof i || void 0 === i || t.objectMode || (o = new TypeError("Invalid non-string/buffer chunk"));
  if (o) {
    e.emit("error", o);
    pna.nextTick(r, o);
    n = !1;
  }
  return n;
}

Writable.prototype.write = function(e, t, i) {
  var r = this._writableState, n = !1, o = !r.objectMode && _isUint8Array(e);
  o && !Buffer.isBuffer(e) && (e = Buffer.from(e));
  if ("function" === typeof t) {
    i = t;
    t = null;
  }
  o ? t = "buffer" : t || (t = r.defaultEncoding);
  "function" !== typeof i && (i = nop);
  if (r.ended) writeAfterEnd(this, i); else if (o || validChunk(this, r, e, i)) {
    r.pendingcb++;
    n = writeOrBuffer(this, r, o, e, t, i);
  }
  return n;
};

Writable.prototype.cork = function() {
  this._writableState.corked++;
};

Writable.prototype.uncork = function() {
  var e = this._writableState;
  if (e.corked) {
    e.corked--;
    e.writing || e.corked || e.finished || e.bufferProcessing || !e.bufferedRequest || clearBuffer(this, e);
  }
};

Writable.prototype.setDefaultEncoding = function(e) {
  "string" === typeof e && (e = e.toLowerCase());
  if (!([ "hex", "utf8", "utf-8", "ascii", "binary", "base64", "ucs2", "ucs-2", "utf16le", "utf-16le", "raw" ].indexOf((e + "").toLowerCase()) > -1)) throw new TypeError("Unknown encoding: " + e);
  this._writableState.defaultEncoding = e;
  return this;
};

function decodeChunk(e, t, i) {
  e.objectMode || !1 === e.decodeStrings || "string" !== typeof t || (t = Buffer.from(t, i));
  return t;
}

Object.defineProperty(Writable.prototype, "writableHighWaterMark", {
  enumerable: !1,
  get: function() {
    return this._writableState.highWaterMark;
  }
});

function writeOrBuffer(e, t, i, r, n, o) {
  if (!i) {
    var s = decodeChunk(t, r, n);
    if (r !== s) {
      i = !0;
      n = "buffer";
      r = s;
    }
  }
  var a = t.objectMode ? 1 : r.length;
  t.length += a;
  var f = t.length < t.highWaterMark;
  f || (t.needDrain = !0);
  if (t.writing || t.corked) {
    var u = t.lastBufferedRequest;
    t.lastBufferedRequest = {
      chunk: r,
      encoding: n,
      isBuf: i,
      callback: o,
      next: null
    };
    u ? u.next = t.lastBufferedRequest : t.bufferedRequest = t.lastBufferedRequest;
    t.bufferedRequestCount += 1;
  } else doWrite(e, t, !1, a, r, n, o);
  return f;
}

function doWrite(e, t, i, r, n, o, s) {
  t.writelen = r;
  t.writecb = s;
  t.writing = !0;
  t.sync = !0;
  i ? e._writev(n, t.onwrite) : e._write(n, o, t.onwrite);
  t.sync = !1;
}

function onwriteError(e, t, i, r, n) {
  --t.pendingcb;
  if (i) {
    pna.nextTick(n, r);
    pna.nextTick(finishMaybe, e, t);
    e._writableState.errorEmitted = !0;
    e.emit("error", r);
  } else {
    n(r);
    e._writableState.errorEmitted = !0;
    e.emit("error", r);
    finishMaybe(e, t);
  }
}

function onwriteStateUpdate(e) {
  e.writing = !1;
  e.writecb = null;
  e.length -= e.writelen;
  e.writelen = 0;
}

function onwrite(e, t) {
  var i = e._writableState, r = i.sync, n = i.writecb;
  onwriteStateUpdate(i);
  if (t) onwriteError(e, i, r, t, n); else {
    var o = needFinish(i);
    o || i.corked || i.bufferProcessing || !i.bufferedRequest || clearBuffer(e, i);
    r ? asyncWrite(afterWrite, e, i, o, n) : afterWrite(e, i, o, n);
  }
}

function afterWrite(e, t, i, r) {
  i || onwriteDrain(e, t);
  t.pendingcb--;
  r();
  finishMaybe(e, t);
}

function onwriteDrain(e, t) {
  if (0 === t.length && t.needDrain) {
    t.needDrain = !1;
    e.emit("drain");
  }
}

function clearBuffer(e, t) {
  t.bufferProcessing = !0;
  var i = t.bufferedRequest;
  if (e._writev && i && i.next) {
    var r = new Array(t.bufferedRequestCount), n = t.corkedRequestsFree;
    n.entry = i;
    var o = 0, s = !0;
    while (i) {
      (r[o] = i).isBuf || (s = !1);
      i = i.next;
      o += 1;
    }
    r.allBuffers = s;
    doWrite(e, t, !0, t.length, r, "", n.finish);
    t.pendingcb++;
    t.lastBufferedRequest = null;
    if (n.next) {
      t.corkedRequestsFree = n.next;
      n.next = null;
    } else t.corkedRequestsFree = new CorkedRequest(t);
    t.bufferedRequestCount = 0;
  } else {
    while (i) {
      var a = i.chunk;
      doWrite(e, t, !1, t.objectMode ? 1 : a.length, a, i.encoding, i.callback);
      i = i.next;
      t.bufferedRequestCount--;
      if (t.writing) break;
    }
    null === i && (t.lastBufferedRequest = null);
  }
  t.bufferedRequest = i;
  t.bufferProcessing = !1;
}

Writable.prototype._write = function(e, t, i) {
  i(new Error("_write() is not implemented"));
};

Writable.prototype._writev = null;

Writable.prototype.end = function(e, t, i) {
  var r = this._writableState;
  if ("function" === typeof e) {
    i = e;
    t = e = null;
  } else if ("function" === typeof t) {
    i = t;
    t = null;
  }
  null !== e && void 0 !== e && this.write(e, t);
  if (r.corked) {
    r.corked = 1;
    this.uncork();
  }
  r.ending || r.finished || endWritable(this, r, i);
};

function needFinish(e) {
  return e.ending && 0 === e.length && null === e.bufferedRequest && !e.finished && !e.writing;
}

function callFinal(t, i) {
  t._final(function(e) {
    i.pendingcb--;
    e && t.emit("error", e);
    i.prefinished = !0;
    t.emit("prefinish");
    finishMaybe(t, i);
  });
}

function prefinish(e, t) {
  if (!t.prefinished && !t.finalCalled) if ("function" === typeof e._final) {
    t.pendingcb++;
    t.finalCalled = !0;
    pna.nextTick(callFinal, e, t);
  } else {
    t.prefinished = !0;
    e.emit("prefinish");
  }
}

function finishMaybe(e, t) {
  var i = needFinish(t);
  if (i) {
    prefinish(e, t);
    if (0 === t.pendingcb) {
      t.finished = !0;
      e.emit("finish");
    }
  }
  return i;
}

function endWritable(e, t, i) {
  t.ending = !0;
  finishMaybe(e, t);
  i && (t.finished ? pna.nextTick(i) : e.once("finish", i));
  e.writable = !(t.ended = !0);
}

function onCorkedFinish(e, t, i) {
  var r = e.entry;
  e.entry = null;
  while (r) {
    var n = r.callback;
    t.pendingcb--;
    n(i);
    r = r.next;
  }
  t.corkedRequestsFree ? t.corkedRequestsFree.next = e : t.corkedRequestsFree = e;
}

Object.defineProperty(Writable.prototype, "destroyed", {
  get: function() {
    return void 0 !== this._writableState && this._writableState.destroyed;
  },
  set: function(e) {
    this._writableState && (this._writableState.destroyed = e);
  }
});

Writable.prototype.destroy = destroyImpl.destroy;

Writable.prototype._undestroy = destroyImpl.undestroy;

Writable.prototype._destroy = function(e, t) {
  this.end();
  t(e);
};
},{"./_stream_duplex":26,"./internal/streams/destroy":32,"./internal/streams/stream":33,"/bundle/utils":3,"buffer":8}],31:[function(require,module,exports){
"use strict";

function _classCallCheck(t, e) {
  if (!(t instanceof e)) throw new TypeError("Cannot call a class as a function");
}

var Buffer = require("buffer").Buffer;

function copyBuffer(t, e, i) {
  t.copy(e, i);
}

module.exports = function() {
  function BufferList() {
    _classCallCheck(this, BufferList);
    this.head = null;
    this.tail = null;
    this.length = 0;
  }
  BufferList.prototype.push = function(t) {
    var e = {
      data: t,
      next: null
    };
    this.length > 0 ? this.tail.next = e : this.head = e;
    this.tail = e;
    ++this.length;
  };
  BufferList.prototype.unshift = function(t) {
    var e = {
      data: t,
      next: this.head
    };
    0 === this.length && (this.tail = e);
    this.head = e;
    ++this.length;
  };
  BufferList.prototype.shift = function() {
    if (0 !== this.length) {
      var t = this.head.data;
      this.head = 1 === this.length ? this.tail = null : this.head.next;
      --this.length;
      return t;
    }
  };
  BufferList.prototype.clear = function() {
    this.head = this.tail = null;
    this.length = 0;
  };
  BufferList.prototype.join = function(t) {
    if (0 === this.length) return "";
    var e = this.head, i = "" + e.data;
    while (e = e.next) i += t + e.data;
    return i;
  };
  BufferList.prototype.concat = function(t) {
    if (0 === this.length) return Buffer.alloc(0);
    if (1 === this.length) return this.head.data;
    var e = Buffer.allocUnsafe(t >>> 0), i = this.head, h = 0;
    while (i) {
      copyBuffer(i.data, e, h);
      h += i.data.length;
      i = i.next;
    }
    return e;
  };
  return BufferList;
}();
},{"buffer":8}],32:[function(require,module,exports){
"use strict";

var pna = require("/bundle/utils");

function destroy(t, e) {
  var r = this;
  if (this._readableState && this._readableState.destroyed || this._writableState && this._writableState.destroyed) {
    e ? e(t) : !t || this._writableState && this._writableState.errorEmitted || pna.nextTick(emitErrorNT, this, t);
    return this;
  }
  this._readableState && (this._readableState.destroyed = !0);
  this._writableState && (this._writableState.destroyed = !0);
  this._destroy(t || null, function(t) {
    if (!e && t) {
      pna.nextTick(emitErrorNT, r, t);
      r._writableState && (r._writableState.errorEmitted = !0);
    } else e && e(t);
  });
  return this;
}

function undestroy() {
  if (this._readableState) {
    this._readableState.destroyed = !1;
    this._readableState.reading = !1;
    this._readableState.ended = !1;
    this._readableState.endEmitted = !1;
  }
  if (this._writableState) {
    this._writableState.destroyed = !1;
    this._writableState.ended = !1;
    this._writableState.ending = !1;
    this._writableState.finished = !1;
    this._writableState.errorEmitted = !1;
  }
}

function emitErrorNT(t, e) {
  t.emit("error", e);
}

module.exports = {
  destroy: destroy,
  undestroy: undestroy
};
},{"/bundle/utils":3}],33:[function(require,module,exports){
module.exports = require("eventemitter3").EventEmitter;
},{"eventemitter3":13}],34:[function(require,module,exports){
"use strict";

var Buffer = require("buffer").Buffer, isEncoding = Buffer.isEncoding || function(t) {
  switch ((t = "" + t) && t.toLowerCase()) {
   case "hex":
   case "utf8":
   case "utf-8":
   case "ascii":
   case "binary":
   case "base64":
   case "ucs2":
   case "ucs-2":
   case "utf16le":
   case "utf-16le":
   case "raw":
    return !0;

   default:
    return !1;
  }
};

function _normalizeEncoding(t) {
  if (!t) return "utf8";
  var e;
  while (1) switch (t) {
   case "utf8":
   case "utf-8":
    return "utf8";

   case "ucs2":
   case "ucs-2":
   case "utf16le":
   case "utf-16le":
    return "utf16le";

   case "latin1":
   case "binary":
    return "latin1";

   case "base64":
   case "ascii":
   case "hex":
    return t;

   default:
    if (e) return;
    t = ("" + t).toLowerCase();
    e = !0;
  }
}

function normalizeEncoding(t) {
  var e = _normalizeEncoding(t);
  if ("string" !== typeof e && (Buffer.isEncoding === isEncoding || !isEncoding(t))) throw new Error("Unknown encoding: " + t);
  return e || t;
}

function StringDecoder(t) {
  this.encoding = normalizeEncoding(t);
  var e;
  switch (this.encoding) {
   case "utf16le":
    this.text = utf16Text;
    this.end = utf16End;
    e = 4;
    break;

   case "utf8":
    this.fillLast = utf8FillLast;
    e = 4;
    break;

   case "base64":
    this.text = base64Text;
    this.end = base64End;
    e = 3;
    break;

   default:
    this.write = simpleWrite;
    this.end = simpleEnd;
    return;
  }
  this.lastNeed = 0;
  this.lastTotal = 0;
  this.lastChar = Buffer.allocUnsafe(e);
}

(exports.StringDecoder = StringDecoder).prototype.write = function(t) {
  if (0 === t.length) return "";
  var e, s;
  if (this.lastNeed) {
    if (void 0 === (e = this.fillLast(t))) return "";
    s = this.lastNeed;
    this.lastNeed = 0;
  } else s = 0;
  return s < t.length ? e ? e + this.text(t, s) : this.text(t, s) : e || "";
};

StringDecoder.prototype.end = utf8End;

StringDecoder.prototype.text = utf8Text;

StringDecoder.prototype.fillLast = function(t) {
  if (this.lastNeed <= t.length) {
    t.copy(this.lastChar, this.lastTotal - this.lastNeed, 0, this.lastNeed);
    return this.lastChar.toString(this.encoding, 0, this.lastTotal);
  }
  t.copy(this.lastChar, this.lastTotal - this.lastNeed, 0, t.length);
  this.lastNeed -= t.length;
};

function utf8CheckByte(t) {
  return t <= 127 ? 0 : t >> 5 === 6 ? 2 : t >> 4 === 14 ? 3 : t >> 3 === 30 ? 4 : t >> 6 === 2 ? -1 : -2;
}

function utf8CheckIncomplete(t, e, s) {
  var i = e.length - 1;
  if (i < s) return 0;
  var n = utf8CheckByte(e[i]);
  if (n >= 0) {
    n > 0 && (t.lastNeed = n - 1);
    return n;
  }
  if (--i < s || -2 === n) return 0;
  if ((n = utf8CheckByte(e[i])) >= 0) {
    n > 0 && (t.lastNeed = n - 2);
    return n;
  }
  if (--i < s || -2 === n) return 0;
  if ((n = utf8CheckByte(e[i])) >= 0) {
    n > 0 && (2 === n ? n = 0 : t.lastNeed = n - 3);
    return n;
  }
  return 0;
}

function utf8CheckExtraBytes(t, e, s) {
  if (128 !== (192 & e[0])) {
    t.lastNeed = 0;
    return "\ufffd";
  }
  if (t.lastNeed > 1 && e.length > 1) {
    if (128 !== (192 & e[1])) {
      t.lastNeed = 1;
      return "\ufffd";
    }
    if (t.lastNeed > 2 && e.length > 2 && 128 !== (192 & e[2])) {
      t.lastNeed = 2;
      return "\ufffd";
    }
  }
}

function utf8FillLast(t) {
  var e = this.lastTotal - this.lastNeed, s = utf8CheckExtraBytes(this, t, e);
  if (void 0 !== s) return s;
  if (this.lastNeed <= t.length) {
    t.copy(this.lastChar, e, 0, this.lastNeed);
    return this.lastChar.toString(this.encoding, 0, this.lastTotal);
  }
  t.copy(this.lastChar, e, 0, t.length);
  this.lastNeed -= t.length;
}

function utf8Text(t, e) {
  var s = utf8CheckIncomplete(this, t, e);
  if (!this.lastNeed) return t.toString("utf8", e);
  var i = t.length - ((this.lastTotal = s) - this.lastNeed);
  t.copy(this.lastChar, 0, i);
  return t.toString("utf8", e, i);
}

function utf8End(t) {
  var e = t && t.length ? this.write(t) : "";
  return this.lastNeed ? e + "\ufffd" : e;
}

function utf16Text(t, e) {
  if ((t.length - e) % 2 === 0) {
    var s = t.toString("utf16le", e);
    if (s) {
      var i = s.charCodeAt(s.length - 1);
      if (i >= 55296 && i <= 56319) {
        this.lastNeed = 2;
        this.lastTotal = 4;
        this.lastChar[0] = t[t.length - 2];
        this.lastChar[1] = t[t.length - 1];
        return s.slice(0, -1);
      }
    }
    return s;
  }
  this.lastNeed = 1;
  this.lastTotal = 2;
  this.lastChar[0] = t[t.length - 1];
  return t.toString("utf16le", e, t.length - 1);
}

function utf16End(t) {
  var e = t && t.length ? this.write(t) : "";
  return this.lastNeed ? e + this.lastChar.toString("utf16le", 0, this.lastTotal - this.lastNeed) : e;
}

function base64Text(t, e) {
  var s = (t.length - e) % 3;
  if (0 === s) return t.toString("base64", e);
  this.lastNeed = 3 - s;
  this.lastTotal = 3;
  if (1 === s) this.lastChar[0] = t[t.length - 1]; else {
    this.lastChar[0] = t[t.length - 2];
    this.lastChar[1] = t[t.length - 1];
  }
  return t.toString("base64", e, t.length - s);
}

function base64End(t) {
  var e = t && t.length ? this.write(t) : "";
  return this.lastNeed ? e + this.lastChar.toString("base64", 0, 3 - this.lastNeed) : e;
}

function simpleWrite(t) {
  return t.toString(this.encoding);
}

function simpleEnd(t) {
  return t && t.length ? this.write(t) : "";
}
},{"buffer":8}],35:[function(require,module,exports){
exports = module.exports = require("./lib/_stream_readable.js");

exports.Stream = exports;

exports.Readable = exports;

exports.Writable = require("./lib/_stream_writable.js");

exports.Duplex = require("./lib/_stream_duplex.js");

exports.Transform = require("./lib/_stream_transform.js");

exports.PassThrough = require("./lib/_stream_passthrough.js");
},{"./lib/_stream_duplex.js":26,"./lib/_stream_passthrough.js":27,"./lib/_stream_readable.js":28,"./lib/_stream_transform.js":29,"./lib/_stream_writable.js":30}],36:[function(require,module,exports){
var Buffer = require("buffer").Buffer;

module.exports = function(e) {
  if (e instanceof Uint8Array) {
    if (0 === e.byteOffset && e.byteLength === e.buffer.byteLength) return e.buffer;
    if ("function" === typeof e.buffer.slice) return e.buffer.slice(e.byteOffset, e.byteOffset + e.byteLength);
  }
  if (Buffer.isBuffer(e)) {
    for (var f = new Uint8Array(e.length), r = e.length, t = 0; t < r; t++) f[t] = e[t];
    return f.buffer;
  }
  throw new Error("Argument must be a Buffer");
};
},{"buffer":8}],37:[function(require,module,exports){
var Buffer = require("buffer").Buffer, UINT_32_MAX = Math.pow(2, 32);

exports.encodingLength = function() {
  return 8;
};

exports.encode = function(e, r, t) {
  r || (r = new Buffer(8));
  t || (t = 0);
  var n = Math.floor(e / UINT_32_MAX), o = e - n * UINT_32_MAX;
  r.writeUInt32BE(n, t);
  r.writeUInt32BE(o, t + 4);
  return r;
};

exports.decode = function(e, r) {
  r || (r = 0);
  e || (e = new Buffer(4));
  r || (r = 0);
  var t = e.readUInt32BE(r), n = e.readUInt32BE(r + 4);
  return t * UINT_32_MAX + n;
};

exports.encode.bytes = 8;

exports.decode.bytes = 8;
},{"buffer":8}],38:[function(require,module,exports){
module.exports = wrappy;

function wrappy(t, r) {
  if (t && r) return wrappy(t)(r);
  if ("function" !== typeof t) throw new TypeError("need wrapper function");
  Object.keys(t).forEach(function(r) {
    wrapper[r] = t[r];
  });
  return wrapper;
  function wrapper() {
    for (var r = new Array(arguments.length), e = 0; e < r.length; e++) r[e] = arguments[e];
    var n = t.apply(this, r), p = r[r.length - 1];
    "function" === typeof n && n !== p && Object.keys(p).forEach(function(r) {
      n[r] = p[r];
    });
    return n;
  }
}
},{}],39:[function(require,module,exports){
"use strict";

var pump = require("pump"), MP4Remuxer = require("./mp4-remuxer"), EBMLRemuxer = require("./ebml-remuxer"), MediaElementWrapper = require("mediasource"), toArrayBuffer = require("to-arraybuffer");

function VideoStream(e, r, t) {
  var i = this;
  if (!(this instanceof VideoStream)) return new VideoStream(e, r, t);
  t = t || {};
  i.detailedError = null;
  i._elem = r;
  i._elemWrapper = new MediaElementWrapper(r, t);
  i._waitingFired = !1;
  i._seekCoercion = !1;
  i._trackMeta = null;
  i._file = e;
  i._tracks = null;
  i._type = t.type;
  i._startTime = t.startTime;
  "none" !== i._elem.preload && i._createMuxer();
  i.flushSourceBuffers = t.sbflush ? i._flushSourceBuffers : function() {};
  i._onError = function(e) {
    i.detailedError = i._elemWrapper.detailedError || e;
    d && console.error("VideoStream Error.", e, i.detailedError);
    i.destroy();
  };
  i._onWaiting = function() {
    i._waitingFired = !0;
    if (i._muxer) {
      if (i._tracks) {
        i._pump(0 | i._startTime);
        i._startTime = null;
      }
    } else i._createMuxer();
  };
  i._elem.addEventListener("waiting", i._onWaiting);
  i._elem.addEventListener("error", i._onError);
}

(module.exports = VideoStream).prototype = Object.create(null);

VideoStream.prototype._createMuxer = function() {
  var i = this;
  i._muxer = "WebM" === i._type ? new EBMLRemuxer(i._file) : new MP4Remuxer(i._file);
  i._muxer.once("ready", function(e) {
    i._tracks = e.map(function(e) {
      var r = i.createWriteStream(e.mime), t = {
        muxed: null,
        mediaSource: r,
        initFlushed: !1,
        onInitFlushed: null
      };
      r.write(e.init, function(e) {
        t.initFlushed = !0;
        t.onInitFlushed && t.onInitFlushed(e);
      });
      return t;
    });
    if (i._waitingFired || "auto" === i._elem.preload) {
      i._pump(0 | i._startTime);
      i._startTime = null;
    }
  });
  i._muxer.on("error", function(e) {
    i._elemWrapper.error(e);
  });
};

VideoStream.prototype.createWriteStream = function(e) {
  var n = this, o = n._elemWrapper.createWriteStream(e), u = o.destroy;
  o._write = function(r, t, i) {
    if (!this.destroyed) {
      var o = this, e = this._sourceBuffer;
      if (e && !e.updating) try {
        if (r.duration) {
          var u = e.buffered.length ? e.buffered.end(0) : 0;
          void 0 !== r.seektime && (!u || u > r.seektime) && (u = r.seektime);
          e.timestampOffset = u;
        }
        e.appendBuffer(toArrayBuffer(r));
        this._cb = i;
        return;
      } catch (e) {
        d > 1 && console.debug("Caught %s", e.name, e);
        if ("QuotaExceededError" !== e.name) return o.destroy(e);
        n.flushSourceBuffers(-1);
      }
      this._cb = function(e) {
        if (e) return i(e);
        o._write(r, t, i);
      };
    }
  };
  o.destroy = function(r) {
    try {
      u.apply(o, arguments);
    } catch (e) {
      var t = this, i = this._sourceBuffer;
      d && console.debug('Caught exception ("%s")', e.name, i && i.updating, i, e);
      if (!i || !i.updating) throw e;
      r && t.emit("error", r);
      t.emit("close");
    }
  };
  o.on("error", function(e) {
    n._elemWrapper.error(e);
  });
  return o;
};

VideoStream.prototype._pump = function(e) {
  try {
    var r = this._elem;
    (0 | e) > 0 && (r.currentTime = e);
    e = r.currentTime;
    "WebM" === self._type && this.withinBufferedRange(e) ? d && console.debug("Ignoring pump within buffered range.", e) : this._tryPump(e);
  } catch (e) {
    this._elemWrapper.error(e);
  }
};

VideoStream.prototype._tryPump = function(o) {
  var u = this, e = u._elem, r = u._muxer, n = r.seek(o), a = r._seekTimeFixup;
  d && console.debug("Seeking to %s, fixup=%s", o, a);
  if (o - a > .4 || 0 === a) {
    var t, i;
    if (u._seekCoercion !== a) {
      d && console.debug("Applying timestamp fixup...", o, a);
      for (t = n.length; t--; ) {
        (i = n[t]).inStream && i.inStream.destroy();
        i.outStream && i.outStream.destroy();
      }
      this.withinBufferedRange(e.currentTime = u._seekCoercion = a) || this._tryPump(a);
      return;
    }
    d && console.debug("Seek coercion, waiting for more data...");
  }
  u._tracks.forEach(function(t, i) {
    var r = function() {
      if (t.muxed) {
        var e = t.mediaSource, r = e && e._sourceBuffer;
        t.muxed.destroy();
        t.mediaSource = u.createWriteStream(e);
        if (r) {
          "audio/mpeg" === e._type && (r.timestampOffset = o);
          void 0 !== a && u.removeBuffered(r, o);
        }
      }
      t.muxed = n[i];
      pump(t.muxed, t.mediaSource);
    };
    t.initFlushed ? r() : t.onInitFlushed = function(e) {
      e ? u._elemWrapper.error(e) : r();
    };
  });
};

VideoStream.prototype.destroy = function() {
  var e = this;
  if (!e.destroyed) {
    e.destroyed = !0;
    e._elem.removeEventListener("waiting", e._onWaiting);
    e._elem.removeEventListener("error", e._onError);
    if (e._tracks) {
      var r, t, i = e._tracks;
      for (r = i.length; r--; ) {
        t = i[r];
        try {
          t.muxed && t.muxed.destroy();
        } catch (e) {
          console.warn(t, e);
        }
      }
    }
    String(e._elem.src).startsWith("blob:") && URL.revokeObjectURL(e._elem.src);
    e._elem.removeAttribute("src");
    e._elem = !1;
  }
};

VideoStream.prototype.forEachSourceBuffer = function(e) {
  if (this._tracks) {
    var r, t, i, o, u, n = this._elem.currentTime;
    for (r = this._tracks.length; r--; ) {
      u = this._tracks[r].mediaSource._mediaSource;
      t = this._tracks[r].mediaSource._sourceBuffer;
      try {
        i = t.buffered.length ? t.buffered.start(0) : 0;
        o = t.buffered.length ? t.buffered.end(t.buffered.length - 1) : 0;
        e.call(this, t, i, o, n, u);
      } catch (e) {
        console.debug(e);
      }
    }
  }
};

VideoStream.prototype.removeBuffered = function(e, r) {
  if (e.buffered.length) {
    var t = e.buffered.start(0), i = e.buffered.end(e.buffered.length - 1);
    d && console.debug("Removing source buffered range (%s:%s-%s)", r, t, i);
    r > t && r < i && (t = r);
    e.remove(t, i);
    return !0;
  }
  return !1;
};

VideoStream.prototype.withinBufferedRange = function(e, r) {
  var t = this.getBufferedRange(r);
  return e > t[0] && t[1] > e;
};

VideoStream.prototype.getBufferedRange = function(e) {
  if (!e) {
    var r = this._tracks, t = r && r[0].mediaSource;
    e = t && t._sourceBuffer;
  }
  return !(!e || !e.buffered.length) && [ e.buffered.start(0), e.buffered.end(e.buffered.length - 1) ];
};

VideoStream.prototype.findTimeGAPs = function() {
  var a = {};
  this.forEachBufferedRanges(function(e, r, t, i, o, u, n) {
    if (n && !a[u]) {
      a[u] = 1;
      console.warn("SourceBuffer has a gap!", [ e ], [ o ]);
    }
    a[u] && console.debug("buffer gap on track%s(%s), sr=%s, er=%s, ct=%s", u, n, r, t, i);
  });
};

VideoStream.prototype.forEachBufferedRanges = function(e) {
  if (this._tracks) {
    var r, t, i, o, u, n, a = this._elem.currentTime;
    for (r = this._tracks.length; r--; ) {
      n = this._tracks[r].mediaSource._mediaSource;
      for (t = (i = this._tracks[r].mediaSource._sourceBuffer).buffered.length; t--; ) try {
        u = i.buffered.end(t);
        o = i.buffered.start(t);
        e.call(this, i, o, u, a, n, r, t);
      } catch (e) {
        console.debug(e);
      }
    }
  }
};

VideoStream.prototype._flushSourceBuffers = function(u) {
  this.forEachSourceBuffer(function(e, r, t, i, o) {
    d && console.debug("[VideoStream.flushSourceBuffers] ct=%s sr=%s er=%s", i, r, t, e.updating, o.readyState, u, e);
    if (!e.updating) {
      if (-1 !== u) t > i ? r = Math.max(i + 1, r) : i >= r && i <= t && (t = i - 1); else {
        t >= i && (t = Math.floor(i));
        if (r >= i) return;
      }
      if (t > r && t - r > 1) {
        e.remove(r, t);
        d && console.log("[VideoStream.flushSourceBuffers] remove took place", r, t);
      }
    }
  });
};

Object.defineProperty(VideoStream.prototype, "bufTime", {
  get: function() {
    var e = 0;
    if (this._muxer instanceof MP4Remuxer) {
      var r = this._muxer._tracks[0] || !1, t = r && r.samples[r.currSample] || !1;
      return (e = (t.dts + t.duration) / r.timeScale) - this._elem.currentTime;
    }
    if (this._muxer instanceof EBMLRemuxer) for (var i = Object(this._tracks).length; i--; ) {
      var o;
      "open" === ((o = this._tracks[i].mediaSource) && o._mediaSource).readyState && (e = Math.max(e, o._getBufferDuration()));
    }
    return e;
  }
});
},{"./ebml-remuxer":4,"./mp4-remuxer":5,"mediasource":15,"pump":24,"to-arraybuffer":36}]},{},[2]);
